(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("chai"), require("sinon"), require("sinon-chai"), require("mocha"), require("../rc-sdk"));
	else if(typeof define === 'function' && define.amd)
		define(["chai", "sinon", "sinon-chai", "mocha", "../rc-sdk"], factory);
	else if(typeof exports === 'object')
		exports["RCSDK"] = factory(require("chai"), require("sinon"), require("sinon-chai"), require("mocha"), require("../rc-sdk"));
	else
		root["RCSDK"] = factory(root["chai"], root["sinon"], root["sinonChai"], root["mocha"], root["RCSDK"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_51__, __WEBPACK_EXTERNAL_MODULE_52__, __WEBPACK_EXTERNAL_MODULE_53__, __WEBPACK_EXTERNAL_MODULE_54__, __WEBPACK_EXTERNAL_MODULE_55__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(57);
__webpack_require__(60);
__webpack_require__(61);
__webpack_require__(62);
__webpack_require__(63);
__webpack_require__(64);
__webpack_require__(65);
__webpack_require__(66);
__webpack_require__(67);
__webpack_require__(68);
__webpack_require__(69);
__webpack_require__(70);
__webpack_require__(71);
__webpack_require__(72);
__webpack_require__(73);
__webpack_require__(74);
__webpack_require__(75);
__webpack_require__(76);
__webpack_require__(77);
__webpack_require__(78);
__webpack_require__(79);
__webpack_require__(80);
__webpack_require__(81);
__webpack_require__(82);
__webpack_require__(83);
__webpack_require__(84);
__webpack_require__(85);
__webpack_require__(86);
__webpack_require__(87);
__webpack_require__(88);
__webpack_require__(90);
__webpack_require__(91);
module.exports = __webpack_require__(58);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ function(module, exports) {

/// <reference path="../../typings/externals.d.ts" />
var hasOwn = Object.prototype.hasOwnProperty, toString = Object.prototype.toString, rdigit = /\d/, class2type = {};
// Populate the class2type map
'Boolean Number String Function Array Date RegExp Object'.split(' ').forEach(function (name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
});
var Utils = (function () {
    function Utils() {
    }
    /**
     * Ported from jQuery.fn.extend
     * Optional first parameter makes deep copy
     */
    Utils.prototype.extend = function (targetObject, sourceObject) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            // skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }
        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !this.isFunction(target)) {
            target = {};
        }
        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) !== null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }
                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (this.isPlainObject(copy) || (copyIsArray = this.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && this.isArray(src) ? src : [];
                        }
                        else {
                            clone = src && this.isPlainObject(src) ? src : {};
                        }
                        // Never move original objects, clone them
                        target[name] = this.extend(deep, clone, copy);
                    }
                    else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        // Return the modified object
        return target;
    };
    Utils.prototype.forEach = function (object, cb) {
        for (var i in object) {
            if (!object.hasOwnProperty(i))
                continue;
            var res = cb(object[i], i);
            if (res === false)
                break;
        }
    };
    /**
     * TODO Replace with something better
     * @see https://github.com/joyent/node/blob/master/lib/querystring.js
     * @param {object} parameters
     * @returns {string}
     */
    Utils.prototype.queryStringify = function (parameters) {
        var _this = this;
        var array = [];
        this.forEach(parameters, function (v, i) {
            if (_this.isArray(v)) {
                v.forEach(function (vv) {
                    array.push(encodeURIComponent(i) + '=' + encodeURIComponent(vv));
                });
            }
            else {
                array.push(encodeURIComponent(i) + '=' + encodeURIComponent(v));
            }
        });
        return array.join('&');
    };
    /**
     * TODO Replace with something better
     * @see https://github.com/joyent/node/blob/master/lib/querystring.js
     * @param {string} queryString
     * @returns {object}
     */
    Utils.prototype.parseQueryString = function (queryString) {
        var argsParsed = {}, self = this;
        queryString.split('&').forEach(function (arg) {
            arg = decodeURIComponent(arg);
            if (arg.indexOf('=') == -1) {
                argsParsed[arg.trim()] = true;
            }
            else {
                var pair = arg.split('='), key = pair[0].trim(), value = pair[1].trim();
                if (key in argsParsed) {
                    if (key in argsParsed && !self.isArray(argsParsed[key]))
                        argsParsed[key] = [argsParsed[key]];
                    argsParsed[key].push(value);
                }
                else {
                    argsParsed[key] = value;
                }
            }
        });
        return argsParsed;
    };
    /**
     * Returns true if the passed value is valid email address.
     * Checks multiple comma separated emails according to RFC 2822 if parameter `multiple` is `true`
     */
    Utils.prototype.isEmail = function (v, multiple) {
        if (!!multiple) {
            //this Regexp is also suitable for multiple emails (comma separated)
            return /^(?:[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?[ ,;]*)+$/i.test(v);
        }
        else {
            return /^[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(v);
        }
    };
    Utils.prototype.isPhoneNumber = function (v) {
        return (/\+?1[0-9]{3}[0-9a-z]{7}/im.test(v.toString().split(/[^0-9a-z\+]/im).join('')));
    };
    /**
     * @param args
     * @returns {Array}
     */
    Utils.prototype.argumentsToArray = function (args) {
        return Array.prototype.slice.call(args || [], 0);
    };
    Utils.prototype.isDate = function (obj) {
        return this.type(obj) === "date";
    };
    Utils.prototype.isFunction = function (obj) {
        return this.type(obj) === "function";
    };
    Utils.prototype.isArray = function (obj) {
        return Array.isArray ? Array.isArray(obj) : this.type(obj) === "array";
    };
    // A crude way of determining if an object is a window
    Utils.prototype.isWindow = function (obj) {
        return obj && typeof obj === "object" && "setInterval" in obj;
    };
    Utils.prototype.isNaN = function (obj) {
        return obj === null || !rdigit.test(obj) || isNaN(obj);
    };
    Utils.prototype.type = function (obj) {
        return obj === null
            ? String(obj)
            : class2type[toString.call(obj)] || "object";
    };
    Utils.prototype.isPlainObject = function (obj) {
        // Must be an Object.
        // Because of IE, we also have to check the presence of the constructor property.
        // Make sure that DOM nodes and window objects don't pass through, as well
        if (!obj || this.type(obj) !== "object" || obj.nodeType || this.isWindow(obj)) {
            return false;
        }
        // Not own constructor property must be Object
        if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
            return false;
        }
        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.
        var key;
        for (key in obj) { }
        return key === undefined || hasOwn.call(obj, key);
    };
    Utils.prototype.getProperty = function (obj, property) {
        return property
            .split(/[.[\]]/)
            .reduce(function (res, part) {
            if (!res)
                return undefined;
            return part ? res[part] : res;
        }, obj);
    };
    Utils.prototype.poll = function (fn, interval, timeout) {
        this.stopPolling(timeout);
        interval = interval || 1000;
        var next = function (delay) {
            delay = delay || interval;
            interval = delay;
            return setTimeout(function () {
                fn(next, delay);
            }, delay);
        };
        return next();
    };
    Utils.prototype.stopPolling = function (timeout) {
        if (timeout)
            clearTimeout(timeout);
    };
    Utils.prototype.parseString = function (s) {
        return s ? s.toString() : '';
    };
    Utils.prototype.parseNumber = function (n) {
        if (!n)
            return 0;
        n = parseFloat(n);
        return isNaN(n) ? 0 : n;
    };
    return Utils;
})();
exports.Utils = Utils;
function $get(context) {
    return context.createSingleton('Utils', function () {
        return new Utils();
    });
}
exports.$get = $get;


/***/ },
/* 5 */,
/* 6 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
var utils = __webpack_require__(4);
var log = __webpack_require__(7);
/**
 * @see https://github.com/Microsoft/TypeScript/issues/275
 */
var Observable = (function () {
    function Observable(context) {
        if (!(this instanceof Observable))
            throw new Error('Observable(): New operator was omitted');
        Object.defineProperty(this, 'listeners', { value: {}, enumerable: false, writable: true });
        Object.defineProperty(this, 'oneTimeEvents', { value: {}, enumerable: false, writable: true });
        Object.defineProperty(this, 'oneTimeArguments', { value: {}, enumerable: false, writable: true });
        this.context = context;
        this.utils = utils.$get(context);
        this.log = log.$get(context);
    }
    Observable.prototype.hasListeners = function (event) {
        return (event in this.listeners);
    };
    /**
     * @deprecated
     * @param {string} event
     */
    Observable.prototype.registerOneTimeEvent = function (event) {
        this.oneTimeEvents[event] = false;
        this.oneTimeArguments[event] = [];
    };
    Observable.prototype.on = function (events, callback) {
        var _this = this;
        if (typeof events == 'string')
            events = [events];
        if (!events)
            throw new Error('No events to subscribe to');
        if (typeof callback !== 'function')
            throw new Error('Callback must be a function');
        var self = this;
        events.forEach(function (event) {
            if (!self.hasListeners(event))
                self.listeners[event] = [];
            self.listeners[event].push(callback);
            if (self.isOneTimeEventFired(event)) {
                _this.log.debug('Observable.on(%s): One-time event has been fired already, executing callback', event);
                callback.apply(self, self.getOneTimeEventArgumens(event));
            }
        });
        return this;
    };
    Observable.prototype.emit = function (event) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.isOneTimeEventFired(event)) {
            this.log.debug('Observable.emit(%s): One-time event has been fired already', event);
            return null;
        }
        var result = null;
        if (this.isOneTimeEvent(event)) {
            this.setOneTimeEventFired(event);
            this.setOneTimeEventArgumens(event, args);
        }
        if (!this.hasListeners(event))
            return null;
        this.listeners[event].some(function (callback) {
            result = callback.apply(_this, args);
            return (result === false);
        });
        return result;
    };
    Observable.prototype.off = function (event, callback) {
        var _this = this;
        if (!event) {
            this.listeners = {};
            this.oneTimeEvents = {};
            this.oneTimeArguments = {};
        }
        else {
            if (!callback) {
                delete this.listeners[event];
            }
            else {
                if (!this.hasListeners(event))
                    return this;
                this.listeners[event].forEach(function (cb, i) {
                    if (cb === callback)
                        delete _this.listeners[event][i];
                });
            }
        }
        return this;
    };
    /**
     * @deprecated
     * @param event
     * @returns {boolean}
     */
    Observable.prototype.isOneTimeEvent = function (event) {
        return (event in this.oneTimeEvents);
    };
    /**
     * @deprecated
     * @param {string} event
     * @returns {boolean}
     */
    Observable.prototype.isOneTimeEventFired = function (event) {
        if (!this.isOneTimeEvent(event))
            return false;
        return (this.oneTimeEvents[event]);
    };
    /**
     * @deprecated
     * @param event
     */
    Observable.prototype.setOneTimeEventFired = function (event) {
        this.oneTimeEvents[event] = true;
    };
    /**
     * @deprecated
     * @param {string} event
     * @param args
     */
    Observable.prototype.setOneTimeEventArgumens = function (event, args) {
        this.oneTimeArguments[event] = args;
    };
    /**
     * @deprecated
     * @param {string} event
     * @returns {any}
     */
    Observable.prototype.getOneTimeEventArgumens = function (event) {
        return this.oneTimeArguments[event];
    };
    /**
     * @deprecated
     * @returns {T}
     */
    Observable.prototype.offAll = function () {
        return this.off();
    };
    Observable.prototype.destroy = function () {
        this.off();
        this.log.debug('Observable.destroy(): Listeners were destroyed');
        return this;
    };
    Observable.prototype.emitAndCallback = function (event, args, callback) {
        args = this.utils.argumentsToArray(args);
        if (event)
            this.emit.apply(this, [event].concat(args));
        if (callback)
            callback.apply(this, args);
        return this;
    };
    return Observable;
})();
exports.Observable = Observable;
function $get(context) {
    return new Observable(context);
}
exports.$get = $get;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
var utils = __webpack_require__(4);
var Log = (function () {
    function Log(context, console) {
        if (!console) {
            console = {
                log: function () { },
                warn: function () { },
                info: function () { },
                error: function () { }
            };
        }
        this.context = context;
        this.console = console;
        this.utils = utils.$get(context);
        this.logDebug = false;
        this.logInfo = false;
        this.logWarnings = false;
        this.logErrors = false;
        this.addTimestamps = false;
    }
    Log.prototype.disableAll = function () {
        this.logDebug = false;
        this.logInfo = false;
        this.logWarnings = false;
        this.logErrors = false;
    };
    Log.prototype.enableAll = function () {
        this.logDebug = true;
        this.logInfo = true;
        this.logWarnings = true;
        this.logErrors = true;
    };
    Log.prototype.parseArguments = function (args) {
        args = this.utils.argumentsToArray(args);
        if (this.addTimestamps)
            args.unshift(new Date().toLocaleString(), '-');
        return args;
    };
    Log.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (this.logDebug)
            this.console.log.apply(this.console, this.parseArguments(arguments));
    };
    Log.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (this.logInfo)
            this.console.info.apply(this.console, this.parseArguments(arguments));
    };
    Log.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (this.logWarnings)
            this.console.warn.apply(this.console, this.parseArguments(arguments));
    };
    Log.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (this.logErrors)
            this.console.error.apply(this.console, this.parseArguments(arguments));
    };
    return Log;
})();
exports.Log = Log;
function $get(context) {
    return context.createSingleton('Log', function () {
        return new Log(context, console);
    });
}
exports.$get = $get;


/***/ },
/* 8 */,
/* 9 */,
/* 10 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var observable = __webpack_require__(6);
var AjaxObserver = (function (_super) {
    __extends(AjaxObserver, _super);
    function AjaxObserver() {
        _super.apply(this, arguments);
        this.events = {
            beforeRequest: 'beforeRequest',
            requestSuccess: 'requestSuccess',
            requestError: 'requestError' // means that request failed completely
        };
    }
    return AjaxObserver;
})(observable.Observable);
exports.AjaxObserver = AjaxObserver;
function $get(context) {
    return context.createSingleton('AjaxObserver', function () {
        return new AjaxObserver(context);
    });
}
exports.$get = $get;


/***/ },
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../../typings/externals.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var h = __webpack_require__(17);
var ajaxObserver = __webpack_require__(10);
var r = __webpack_require__(18);
/**
 * TODO @see https://github.com/github/fetch/blob/master/fetch.js
 */
var Request = (function (_super) {
    __extends(Request, _super);
    function Request(context) {
        _super.call(this, context);
        this.async = true;
        this.method = '';
        this.url = '';
        this.query = null;
        this.body = {};
        this.context = context;
        this.xhr = null;
        this.observer = ajaxObserver.$get(context);
    }
    Request.prototype.isLoaded = function () {
        return !!this.xhr;
    };
    Request.prototype.setOptions = function (options) {
        options = options || {};
        // backwards compatibility
        if (!('body' in options) && options.post)
            options.body = options.post;
        if (!('query' in options) && options.get)
            options.query = options.get;
        if ('method' in options)
            this.method = options.method;
        if ('url' in options)
            this.url = options.url;
        if ('query' in options)
            this.query = options.query;
        if ('body' in options)
            this.body = options.body;
        if ('headers' in options)
            this.setHeaders(options.headers);
        if ('async' in options)
            this.async = !!options.async;
        return this;
    };
    /**
     * Checks the send options, defaulting various of the options,
     * and consuming / transforming some of the options (like get).
     */
    Request.prototype.checkOptions = function () {
        if (!this.url)
            throw new Error('Url is not defined');
        if (!this.hasHeader('Accept'))
            this.setHeader('Accept', h.Headers.jsonContentType);
        if (!this.hasHeader('Content-Type'))
            this.setHeader('Content-Type', h.Headers.jsonContentType);
        this.method = this.method ? this.method.toUpperCase() : 'GET';
        if (['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'].indexOf(this.method) < 0)
            throw new Error('Method has wrong value');
        return this;
    };
    Request.prototype.getEncodedBody = function () {
        if (this.method === 'GET')
            return null;
        if (typeof this.body === 'string') {
            return this.body;
        }
        else if (this.isJson()) {
            return JSON.stringify(this.body);
        }
        else if (this.isUrlEncoded()) {
            return this.utils.queryStringify(this.body);
        }
        else {
            return this.body;
        }
    };
    Request.prototype.send = function () {
        var _this = this;
        this.observer.emit(this.observer.events.beforeRequest, this);
        var responsePromise = new (this.context.getPromise())(function (resolve, reject) {
            _this.checkOptions();
            var xhr = _this.getXHR(), url = _this.url + (!!_this.query ? ((_this.url.indexOf('?') > -1 ? '&' : '?') + _this.utils.queryStringify(_this.query)) : '');
            xhr.open(_this.method, url, _this.async);
            //@see http://stackoverflow.com/questions/19666809/cors-withcredentials-support-limited
            xhr.withCredentials = true;
            xhr.onload = function () {
                //TODO http://jira.ringcentral.com/browse/PLA-10585
                var response = r.$get(_this.context, xhr.status, xhr.statusText, xhr.responseText, xhr.getAllResponseHeaders());
                if (response.error) {
                    var e = response.error;
                    e.ajax = response; // backwards compatibility
                    e.response = response; //FIXME Circular
                    e.request = _this;
                    reject(e);
                }
                else {
                    resolve(response);
                }
            };
            xhr.onerror = function (event) {
                var e = new Error('The request cannot be sent' + (event ? ' (' + event.toString() + ')' : ''));
                e.request = _this;
                e.response = null;
                e.ajax = null; // backwards compatibility
                reject(e);
            };
            _this.utils.forEach(_this.headers, function (value, header) {
                if (!!value)
                    xhr.setRequestHeader(header, value);
            });
            xhr.send(_this.getEncodedBody());
            _this.xhr = xhr;
        });
        return responsePromise.then(function (response) {
            _this.observer.emit(_this.observer.events.requestSuccess, response, _this);
            return response;
        }).catch(function (e) {
            _this.observer.emit(_this.observer.events.requestError, e);
            throw e;
        });
    };
    Request.prototype.getXHR = function () {
        return this.context.getXHR();
    };
    Request.prototype.destroy = function () {
        if (this.xhr)
            this.xhr.abort();
    };
    return Request;
})(h.Headers);
exports.Request = Request;
function $get(context) {
    return new Request(context);
}
exports.$get = $get;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../../typings/externals.d.ts" />
var utils = __webpack_require__(4);
/**
 * @see https://github.com/Microsoft/TypeScript/issues/275
 */
var Headers = (function () {
    function Headers(context) {
        this.headers = {};
        this.context = context;
        this.utils = utils.$get(context);
    }
    Headers.prototype.setHeader = function (name, value) {
        this.headers[name.toLowerCase()] = value;
        return this;
    };
    Headers.prototype.getHeader = function (name) {
        return this.headers[name.toLowerCase()];
    };
    Headers.prototype.hasHeader = function (name) {
        return (name.toLowerCase() in this.headers);
    };
    Headers.prototype.setHeaders = function (headers) {
        var _this = this;
        this.utils.forEach(headers, function (value, name) {
            _this.setHeader(name, value);
        });
        return this;
    };
    Headers.prototype.isContentType = function (contentType) {
        return this.getContentType().indexOf(contentType) > -1;
    };
    Headers.prototype.setContentType = function (contentType) {
        this.setHeader(Headers.contentType, contentType);
        return this;
    };
    Headers.prototype.getContentType = function () {
        return this.getHeader(Headers.contentType) || '';
    };
    Headers.prototype.isMultipart = function () {
        return this.isContentType(Headers.multipartContentType);
    };
    Headers.prototype.isUrlEncoded = function () {
        return this.isContentType(Headers.urlencodedContentType);
    };
    Headers.prototype.isJson = function () {
        return this.isContentType(Headers.jsonContentType);
    };
    Headers.contentType = 'Content-Type';
    Headers.jsonContentType = 'application/json';
    Headers.multipartContentType = 'multipart/mixed';
    Headers.urlencodedContentType = 'application/x-www-form-urlencoded';
    return Headers;
})();
exports.Headers = Headers;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../../typings/externals.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var h = __webpack_require__(17);
var log = __webpack_require__(7);
var Response = (function (_super) {
    __extends(Response, _super);
    function Response(context, status, statusText, body, headers) {
        var _this = this;
        _super.call(this, context);
        this.log = log.$get(context);
        if (typeof (body) === 'string') {
            body = body.replace(/\r/g, '');
            if (!headers) {
                var tmp = body.split(Response.bodySeparator);
                headers = (tmp.length > 1) ? tmp.shift() : {};
                body = tmp.join(Response.bodySeparator);
            }
        }
        /** @type {Response[]|object} */
        this.data = null;
        /** @type {object} */
        this.json = null;
        /** @type {Response[]} */
        this.responses = [];
        /** @type {Error} */
        this.error = null;
        //@see http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
        if (status == 1223)
            status = 204;
        this.status = status;
        this.statusText = statusText;
        this.body = body;
        try {
            // Step 1. Parse headers
            if (typeof (headers) === 'string') {
                (headers || '')
                    .split('\n')
                    .forEach(function (header) {
                    if (!header)
                        return;
                    var parts = header.split(Response.headerSeparator), name = parts.shift().trim();
                    _this.setHeader(name, parts.join(Response.headerSeparator).trim());
                });
            }
            else {
                this.setHeaders(headers);
            }
            // Step 1.1. JEDI proxy sometimes may omit Content-Type header
            if (!this.hasHeader(h.Headers.contentType))
                this.setHeader(h.Headers.contentType, h.Headers.jsonContentType);
            // Step 2. Parse body
            if (this.isJson() && !!this.body && typeof (this.body) === 'string') {
                this.json = JSON.parse(this.body);
                this.data = this.json; // backwards compatibility
                if (!this.checkStatus())
                    this.error = new Error(this.getError());
            }
            else if (this.isMultipart()) {
                // Step 2.1. Split multipart response
                var boundary = this.getContentType().match(/boundary=([^;]+)/i)[1], parts = this.body.split(Response.boundarySeparator + boundary);
                if (parts[0].trim() === '')
                    parts.shift();
                if (parts[parts.length - 1].trim() == Response.boundarySeparator)
                    parts.pop();
                // Step 2.2. Parse status info
                var statusInfo = new Response(this.context, this.status, '', parts.shift());
                // Step 2.3. Parse all other parts
                this.responses = parts.map(function (part, i) {
                    var status = statusInfo.data.response[i].status;
                    return new Response(_this.context, status, '', part);
                });
                this.data = this.responses; // backwards compatibility
            }
            else {
                this.data = this.body;
            }
        }
        catch (e) {
            this.log.error('Response.parseResponse(): Unable to parse data');
            this.log.error(e.stack || e);
            this.log.error(this.body);
            this.error = e;
        }
    }
    /**
     * @returns {boolean}
     */
    Response.prototype.isUnauthorized = function () {
        return (this.status == 401);
    };
    Response.prototype.checkStatus = function () {
        return this.status >= 200 && this.status < 300;
    };
    Response.prototype.getError = function () {
        return this.data.message ||
            this.data.error_description ||
            this.data.description ||
            'Unknown error';
    };
    Response.boundarySeparator = '--';
    Response.headerSeparator = ':';
    Response.bodySeparator = '\n\n';
    return Response;
})(h.Headers);
exports.Response = Response;
function $get(context, status, statusText, body, headers) {
    return new Response(context, status, statusText, body, headers);
}
exports.$get = $get;


/***/ },
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_51__;

/***/ },
/* 52 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_52__;

/***/ },
/* 53 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_53__;

/***/ },
/* 54 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_54__;

/***/ },
/* 55 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_55__;

/***/ },
/* 56 */,
/* 57 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
describe('RCSDK', function () {
    describe('actual connection', function () {
        it.skip('connects to sandbox', function (done) {
            this.timeout(10000); // Per SLA should be 3 seconds
            var server = exports.mocha.RCSDK.url.sandbox, rcsdk = new exports.mocha.RCSDK({ server: server, appKey: '', appSecret: '' }), platform = rcsdk.getPlatform();
            platform.forceAuthentication();
            platform
                .apiCall({
                url: ''
            })
                .then(function (ajax) {
                expect(ajax.data.uri).to.equal(server + '/restapi/v1.0');
                done();
            })
                .catch(function (e) {
                done(e);
            });
        });
        it.skip('connects to production', function (done) {
            this.timeout(10000); // Per SLA should be 3 seconds
            var server = exports.mocha.RCSDK.url.production, rcsdk = new exports.mocha.RCSDK({ server: server, appKey: '', appSecret: '' }), platform = rcsdk.getPlatform();
            platform.forceAuthentication();
            platform
                .apiCall({
                url: ''
            })
                .then(function (ajax) {
                expect(ajax.data.uri).to.equal(server + '/restapi/v1.0');
                done();
            })
                .catch(function (e) {
                done(e);
            });
        });
    });
});


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../typings/externals.d.ts" />
var _mock = __webpack_require__(59);
exports.chai = __webpack_require__(51);
exports.sinon = __webpack_require__(52);
exports.sinonChai = __webpack_require__(53);
exports.mocha = __webpack_require__(54);
exports.RCSDK = __webpack_require__(55);
exports.rcsdk = new exports.RCSDK({
    server: 'http://whatever',
    appKey: 'whatever',
    appSecret: 'whatever'
});
exports.mock = new _mock.Mock(exports.rcsdk);
exports.chai.use(exports.sinonChai);


/***/ },
/* 59 */
/***/ function(module, exports) {

/// <reference path="../../typings/externals.d.ts" />
var Mock = (function () {
    function Mock(rcsdk) {
        this.rcsdk = rcsdk;
        var platform = rcsdk.getPlatform();
        rcsdk.getContext()
            .useAjaxStub(true)
            .usePubnubStub(true);
        platform.pollInterval = 1;
        platform.refreshDelayMs = 1;
    }
    Mock.prototype.registerHooks = function (suite, username) {
        var _this = this;
        suite.afterEach(function (done) {
            //this.rcsdk.getPlatform()
            //    .logout()
            //    .then(function() {
            //        done();
            //    })
            //    .catch(done);
            done();
        });
        this.registerCleanup(suite);
        suite.beforeEach(function (done) {
            _this.authentication();
            _this.rcsdk.getPlatform()
                .authorize({
                username: username || 'whatever',
                password: 'whatever'
            })
                .then(function () {
                done();
            })
                .catch(done);
        });
    };
    Mock.prototype.registerCleanup = function (suite) {
        var _this = this;
        var cleanup = function () {
            _this.rcsdk.getCache().clean();
            // Clear events and all for singletons
            _this.rcsdk.getPlatform().destroy();
            _this.rcsdk.getXhrResponse().clear();
        };
        suite.beforeEach(function (done) {
            cleanup();
            done();
        });
        suite.afterEach(function (done) {
            cleanup();
            done();
        });
    };
    Mock.prototype.apiCall = function (path, response, status) {
        this.rcsdk.getXhrResponse().add({
            path: path,
            response: function (ajax) {
                ajax.setStatus(status || 200);
                return response;
            }
        });
    };
    Mock.prototype.authentication = function () {
        this.rcsdk.getXhrResponse().add({
            path: '/restapi/oauth/token',
            response: function (ajax) {
                return {
                    'access_token': 'ACCESS_TOKEN',
                    'token_type': 'bearer',
                    'expires_in': 3600,
                    'refresh_token': 'REFRESH_TOKEN',
                    'refresh_token_expires_in': 60480,
                    'scope': 'SMS RCM Foo Boo',
                    'expireTime': new Date().getTime() + 3600000
                };
            },
            test: function (ajax) {
                return (!ajax.data || !ajax.data['refresh_token']);
            }
        });
        this.rcsdk.getXhrResponse().add({
            path: '/restapi/oauth/revoke',
            response: function (ajax) {
                return {};
            }
        });
    };
    Mock.prototype.presenceLoad = function (id, detailed) {
        this.rcsdk.getXhrResponse().add({
            path: '/restapi/v1.0/account/~/extension/' + id + '/presence',
            response: function (ajax) {
                return {
                    "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id + "/presence",
                    "extension": {
                        "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id,
                        "id": id,
                        "extensionNumber": "101"
                    },
                    "activeCalls": [],
                    "presenceStatus": "Available",
                    "telephonyStatus": "Ringing",
                    "userStatus": "Available",
                    "dndStatus": "TakeAllCalls",
                    "extensionId": id
                };
            }
        });
    };
    Mock.prototype.subscribeGeneric = function (expiresIn) {
        this.rcsdk.getXhrResponse().add({
            path: '/restapi/v1.0/subscription',
            response: function (ajax) {
                expiresIn = expiresIn || 15 * 60 * 60;
                var date = new Date();
                return {
                    'eventFilters': ajax.data.eventFilters,
                    'expirationTime': new Date(date.getTime() + (expiresIn * 1000)).toISOString(),
                    'expiresIn': expiresIn,
                    'deliveryMode': {
                        'transportType': 'PubNub',
                        'encryption': false,
                        'address': '123_foo',
                        'subscriberKey': 'sub-c-foo',
                        'secretKey': 'sec-c-bar'
                    },
                    'id': 'foo-bar-baz',
                    'creationTime': date.toISOString(),
                    'status': 'Active',
                    'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
                };
            }
        });
    };
    Mock.prototype.subscribeOnPresence = function (id, detailed) {
        id = id || '1';
        this.rcsdk.getXhrResponse().add({
            path: '/restapi/v1.0/subscription',
            response: function (ajax) {
                var date = new Date();
                return {
                    'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],
                    'expirationTime': new Date(date.getTime() + (15 * 60 * 60 * 1000)).toISOString(),
                    'deliveryMode': {
                        'transportType': 'PubNub',
                        'encryption': true,
                        'address': '123_foo',
                        'subscriberKey': 'sub-c-foo',
                        'secretKey': 'sec-c-bar',
                        'encryptionAlgorithm': 'AES',
                        'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='
                    },
                    'creationTime': date.toISOString(),
                    'id': 'foo-bar-baz',
                    'status': 'Active',
                    'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
                };
            }
        });
    };
    Mock.prototype.tokenRefresh = function (failure) {
        this.rcsdk.getXhrResponse().add({
            path: '/restapi/oauth/token',
            response: function (ajax) {
                if (!failure)
                    return {
                        'access_token': 'ACCESS_TOKEN_FROM_REFRESH',
                        'token_type': 'bearer',
                        'expires_in': 3600,
                        'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',
                        'refresh_token_expires_in': 60480,
                        'scope': 'SMS RCM Foo Boo',
                        'expireTime': new Date().getTime() + 3600000
                    };
                ajax.setStatus(400);
                return {
                    'message': 'Wrong token',
                    'error_description': 'Wrong token',
                    'description': 'Wrong token'
                };
            },
            test: function (ajax) {
                return (ajax.data && ajax.data['refresh_token']);
            }
        });
    };
    return Mock;
})();
exports.Mock = Mock;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.dictionaries.Timezone', function () {
    'use strict';
    var Timezone = rcsdk.getTimezoneHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Timezone.createUrl()).to.equal('/dictionary/timezone');
        });
    });
});


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.dictionaries.State', function () {
    'use strict';
    var State = rcsdk.getStateHelper();
    var states = [
        { id: 1, country: { id: '1' } },
        { id: 2, country: { id: '2' } },
        { id: 3, country: { id: '2' } },
        { id: 4, country: { id: '1' } }
    ];
    describe('filter', function () {
        it('filters by countryId', function () {
            var filtered = states.filter(State.filter({ countryId: '2' }));
            expect(filtered.length).to.equal(2);
            expect(filtered[0]).to.equal(states[1]);
            expect(filtered[1]).to.equal(states[2]);
        });
    });
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(State.createUrl()).to.equal('/dictionary/state');
        });
    });
});


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Service', function () {
    describe('Convenience methods', function () {
        it('allows to determine account features availability via set of methods', function () {
            function testMethods(value) {
                var features = [
                    { "featureName": "SMS", "enabled": value },
                    { "featureName": "SMSReceiving", "enabled": value },
                    { "featureName": "Pager", "enabled": value },
                    { "featureName": "PagerReceiving", "enabled": value },
                    { "featureName": "Voicemail", "enabled": value },
                    { "featureName": "Fax", "enabled": value },
                    { "featureName": "FaxReceiving", "enabled": value },
                    { "featureName": "DND", "enabled": value },
                    { "featureName": "RingOut", "enabled": value },
                    { "featureName": "InternationalCalling", "enabled": value },
                    { "featureName": "Presence", "enabled": value },
                    { "featureName": "VideoConferencing", "enabled": value },
                    { "featureName": "SalesForce", "enabled": value },
                    { "featureName": "Intercom", "enabled": value },
                    { "featureName": "Paging", "enabled": value },
                    { "featureName": "Conferencing", "enabled": value },
                    { "featureName": "VoipCalling", "enabled": value },
                    { "featureName": "FreeSoftPhoneLines", "enabled": value },
                    { "featureName": "HipaaCompliance", "enabled": value },
                    { "featureName": "CallPark", "enabled": value },
                    { "featureName": "OnDemandCallRecording", "enabled": value }
                ], service = rcsdk.getServiceHelper();
                expect(service.isSmsEnabled(features)).to.equal(value);
                expect(service.isSmsReceivingEnabled(features)).to.equal(value);
                expect(service.isPagerEnabled(features)).to.equal(value);
                expect(service.isPagerReceivingEnabled(features)).to.equal(value);
                expect(service.isVoicemailEnabled(features)).to.equal(value);
                expect(service.isFaxEnabled(features)).to.equal(value);
                expect(service.isFaxReceivingEnabled(features)).to.equal(value);
                expect(service.isDndEnabled(features)).to.equal(value);
                expect(service.isRingOutEnabled(features)).to.equal(value);
                expect(service.isInternationalCallingEnabled(features)).to.equal(value);
                expect(service.isPresenceEnabled(features)).to.equal(value);
                expect(service.isVideoConferencingEnabled(features)).to.equal(value);
                expect(service.isSalesForceEnabled(features)).to.equal(value);
                expect(service.isIntercomEnabled(features)).to.equal(value);
                expect(service.isPagingEnabled(features)).to.equal(value);
                expect(service.isConferencingEnabled(features)).to.equal(value);
                expect(service.isVoipCallingEnabled(features)).to.equal(value);
                expect(service.isFreeSoftPhoneLinesEnabled(features)).to.equal(value);
                expect(service.isHipaaComplianceEnabled(features)).to.equal(value);
                expect(service.isCallParkEnabled(features)).to.equal(value);
                expect(service.isOnDemandCallRecordingEnabled(features)).to.equal(value);
            }
            testMethods(true);
            testMethods(false);
        });
    });
});


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Ringout', function () {
    'use strict';
    var Ringout = rcsdk.getRingoutHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Ringout.createUrl()).to.equal('/account/~/extension/~/ringout');
            expect(Ringout.createUrl({}, 'foo')).to.equal('/account/~/extension/~/ringout/foo');
            expect(Ringout.createUrl({ extensionId: 'foo' })).to.equal('/account/~/extension/foo/ringout');
            expect(Ringout.createUrl({ extensionId: 'foo' }, 'bar')).to.equal('/account/~/extension/foo/ringout/bar');
        });
    });
    describe('status helpers', function () {
        it('unsaved ringout is not inProgress/error/success', function () {
            expect(Ringout.isSuccess({ status: { callStatus: 'InProgress' } })).to.equal(false);
            expect(Ringout.isError({ status: { callStatus: 'Error' } })).to.equal(false);
            expect(Ringout.isInProgress({ status: { callStatus: 'Success' } })).to.equal(false);
        });
        it('provides interfaces to determine statuses', function () {
            expect(Ringout.isSuccess({ id: 'foo', uri: 'bar', status: { callStatus: 'InProgress' } })).to.equal(false);
            expect(Ringout.isError({ id: 'foo', uri: 'bar', status: { callStatus: 'InProgress' } })).to.equal(false);
            expect(Ringout.isInProgress({ id: 'foo', uri: 'bar', status: { callStatus: 'InProgress' } })).to.equal(true);
            expect(Ringout.isSuccess({ id: 'foo', uri: 'bar', status: { callStatus: 'Success' } })).to.equal(true);
            expect(Ringout.isError({ id: 'foo', uri: 'bar', status: { callStatus: 'Success' } })).to.equal(false);
            expect(Ringout.isInProgress({ id: 'foo', uri: 'bar', status: { callStatus: 'Success' } })).to.equal(false);
            expect(Ringout.isSuccess({ id: 'foo', uri: 'bar', status: { callStatus: 'Error' } })).to.equal(false);
            expect(Ringout.isError({ id: 'foo', uri: 'bar', status: { callStatus: 'Error' } })).to.equal(true);
            expect(Ringout.isInProgress({ id: 'foo', uri: 'bar', status: { callStatus: 'Error' } })).to.equal(false);
        });
    });
    describe('validate', function () {
        it('performs basic validation', function () {
            var res = Ringout.validate({});
            expect(res.isValid).to.equal(false);
            expect(res.errors['to'][0]).to.be.instanceOf(Error);
            expect(res.errors['to'].length).to.equal(1);
            expect(res.errors['from'][0]).to.be.instanceOf(Error);
            expect(res.errors['from'].length).to.equal(1);
        });
        it('passes validation if values are correct', function () {
            var res = Ringout.validate({ to: { phoneNumber: 'foo' }, from: { phoneNumber: 'foo' } });
            expect(res.isValid).to.equal(true);
            expect(res.errors).to.deep.equal({});
        });
    });
});


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Presence', function () {
    'use strict';
    var Presence = rcsdk.getPresenceHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Presence.createUrl()).to.equal('/account/~/extension/~/presence');
            expect(Presence.createUrl({}, 'foo')).to.equal('/account/~/extension/foo/presence');
            expect(Presence.createUrl({ detailed: true }, 'foo')).to.equal('/account/~/extension/foo/presence?detailedTelephonyState=true');
        });
    });
    describe('attachToExtensions', function () {
        it('attaches presence to all matching extensions', function () {
            var presences = [
                { extension: { id: 'foo' }, presenceStatus: 'Offline' },
                { extension: { id: 'bar' }, presenceStatus: 'Busy' },
                { extension: { id: 'baz' }, presenceStatus: 'Available' }
            ], extensions = [
                { id: 'foo' },
                { id: 'bar' },
                { id: 'baz' },
                { id: 'qux' }
            ];
            Presence.attachToExtensions(extensions, presences);
            expect(extensions[0].presence).to.equal(presences[0]);
            expect(extensions[1].presence).to.equal(presences[1]);
            expect(extensions[2].presence).to.equal(presences[2]);
            expect(extensions[3].presence).to.be.an('undefined');
        });
        it('attaches presence to all matching extensions (with merge)', function () {
            var presences = [
                { extensionId: 'baz', presenceStatus: 'Available', foo: 'bar' }
            ], extensions = [
                { id: 'baz', presence: { foo: 'baz' } }
            ];
            expect(extensions[0].presence.foo).to.equal('baz');
            Presence.attachToExtensions(extensions, presences, true);
            expect(extensions[0].presence.foo).to.equal('bar');
            expect(extensions[0].presence.presenceStatus).to.equal('Available');
        });
    });
    describe('getSubscription', function () {
        it('returns pre-configured Subscription object', function () {
            var notificaction = Presence.getSubscription({ detailed: true }, 'foo');
            expect(notificaction.eventFilters.length).to.equal(1);
            expect(notificaction.eventFilters[0]).to.equal('/account/~/extension/foo/presence?detailedTelephonyState=true');
        });
    });
    describe('updateSubscription', function () {
        it('adds proper events to Subscription object', function () {
            var notificaction = rcsdk.getSubscription();
            expect(notificaction.eventFilters.length).to.equal(0);
            Presence.updateSubscription(notificaction, [{ extension: { id: 'foo' } }, { extension: { id: 'bar' } }], { detailed: true });
            expect(notificaction.eventFilters.length).to.equal(2);
            expect(notificaction.eventFilters[0]).to.equal('/account/~/extension/foo/presence?detailedTelephonyState=true');
            expect(notificaction.eventFilters[1]).to.equal('/account/~/extension/bar/presence?detailedTelephonyState=true');
        });
    });
});


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.ForwardingNumber', function () {
    'use strict';
    var PhoneNumber = rcsdk.getPhoneNumberHelper();
    var phoneNumbers = [
        { usageType: 'MainCompanyNumber', paymentType: 'TollFree', type: 'VoiceFax', phoneNumber: '1', features: [] },
        { usageType: 'AdditionalCompanyNumber', paymentType: 'TollFree', type: 'Voice', phoneNumber: '1', features: [] },
        { usageType: 'AdditionalCompanyNumber', paymentType: 'Local', type: 'VoiceFax', phoneNumber: '1', features: [] },
        { usageType: 'CompanyNumber', paymentType: 'Local', type: 'VoiceFax', phoneNumber: '1', features: [] },
        {
            usageType: 'DirectNumber',
            paymentType: 'Local',
            type: 'VoiceFax',
            phoneNumber: '1',
            features: ['SmsSender', 'CallerId']
        },
        { usageType: 'CompanyNumber', paymentType: 'Local', type: 'VoiceFax', phoneNumber: '1', features: [] },
        { usageType: 'CompanyFaxNumber', paymentType: 'Local', type: 'Fax', phoneNumber: '1', features: [] },
        { usageType: 'ForwardedNumber', paymentType: 'Local', type: 'VoiceFax', phoneNumber: '1', features: [] }
    ];
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(PhoneNumber.createUrl()).to.equal('/account/~/phone-number');
            expect(PhoneNumber.createUrl({ extensionId: 'foo' })).to.equal('/account/~/extension/foo/phone-number');
            expect(PhoneNumber.createUrl({ extensionId: 'foo' }, 'bar')).to.equal('/account/~/extension/foo/phone-number/bar');
            expect(PhoneNumber.createUrl({}, 'bar')).to.equal('/account/~/phone-number/bar');
            expect(PhoneNumber.createUrl({ lookup: true })).to.equal('/number-pool/lookup');
        });
    });
    describe('comparator', function () {
        it('sorts by usageType, paymentType, type by default', function () {
            var phoneNumbers = [
                { usageType: '2', paymentType: '1', type: '1' },
                { usageType: '1', paymentType: '2', type: '2' },
                { usageType: '1', paymentType: '2', type: '1' },
                { usageType: '1', paymentType: '1', type: '1' }
            ];
            var sorted = [].concat(phoneNumbers).sort(PhoneNumber.comparator());
            expect(sorted[0]).to.equal(phoneNumbers[3]);
            expect(sorted[1]).to.equal(phoneNumbers[2]);
            expect(sorted[2]).to.equal(phoneNumbers[1]);
            expect(sorted[3]).to.equal(phoneNumbers[0]);
        });
    });
    describe('filter', function () {
        it('provides functionality to filter by feature', function () {
            var filtered = [];
            filtered = phoneNumbers.filter(PhoneNumber.filter({ features: ['SmsSender'] }));
            expect(filtered.length).to.equal(1);
            expect(filtered[0]).to.equal(phoneNumbers[4]);
        });
    });
});


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Message', function () {
    'use strict';
    var Message = rcsdk.getMessageHelper();
    describe('attachContacts', function () {
        it('attaches contacts to all callerInfo structures found in each call', function () {
            var contacts = [
                { id: 'foo', homePhone: 'foo' },
                { id: 'bar', homePhone: 'bar' },
                { id: 'baz', homePhone: 'baz' }
            ], messages = [
                {
                    direction: 'Outbound',
                    from: { phoneNumber: 'foo' },
                    to: [
                        { phoneNumber: 'bar' },
                        { phoneNumber: 'baz' }
                    ]
                },
                {
                    direction: 'Inbound',
                    from: { phoneNumber: 'baz' },
                    to: [
                        { phoneNumber: 'notfound' }
                    ]
                }
            ];
            Message.attachContacts(contacts, messages);
            expect(messages[0].from.contact).to.equal(contacts[0]);
            expect(messages[0].to[0].contact).to.equal(contacts[1]);
            expect(messages[0].to[1].contact).to.equal(contacts[2]);
            expect(messages[1].from.contact).to.equal(contacts[2]);
            expect(messages[1].to[0].contact).to.be.an('undefined');
        });
    });
    describe('getCallerInfo', function () {
        var messages = [
            {
                direction: 'Outbound',
                from: {
                    phoneNumber: 'foo'
                },
                to: [
                    { phoneNumber: 'bar' },
                    { phoneNumber: 'baz' }
                ]
            },
            {
                direction: 'Inbound',
                from: { phoneNumber: 'baz' },
                to: [
                    { phoneNumber: 'qux' }
                ]
            }
        ];
        it('returns callerInfo of from or to properties depending on direction', function () {
            expect(Message.getCallerInfos(messages[0]).length).to.equal(2);
            expect(Message.getCallerInfos(messages[0])[0].phoneNumber).to.equal('bar');
            expect(Message.getCallerInfos(messages[0])[1].phoneNumber).to.equal('baz');
            expect(Message.getCallerInfos(messages[1]).length).to.equal(1);
            expect(Message.getCallerInfos(messages[1])[0].phoneNumber).to.equal('baz');
        });
        it('returms all callerInfos in an order depending on direction', function () {
            expect(Message.getAllCallerInfos(messages[0]).length).to.equal(3);
            expect(Message.getAllCallerInfos(messages[0])[0].phoneNumber).to.equal('bar');
            expect(Message.getAllCallerInfos(messages[0])[1].phoneNumber).to.equal('baz');
            expect(Message.getAllCallerInfos(messages[0])[2].phoneNumber).to.equal('foo');
            expect(Message.getAllCallerInfos(messages[1]).length).to.equal(2);
            expect(Message.getAllCallerInfos(messages[1])[0].phoneNumber).to.equal('baz');
            expect(Message.getAllCallerInfos(messages[1])[1].phoneNumber).to.equal('qux');
        });
    });
    describe('shorten', function () {
        it('creates a short message out of full message structure', function () {
            var message = {
                direction: 'Outbound',
                subject: 'qux',
                from: {
                    phoneNumber: 'foo'
                },
                to: [
                    { phoneNumber: 'bar' },
                    { phoneNumber: 'baz' }
                ]
            }, short = Message.shorten(message);
            expect(short.direction).to.be.an('undefined');
            expect(short.subject).to.be.an('undefined');
            expect(short.text).to.equal(message.subject);
            expect(short.from).to.equal(message.from);
            expect(short.to).to.equal(message.to);
        });
    });
    describe('createUrl', function () {
        it('produces various urls depending on options', function () {
            expect(Message.createUrl()).to.equal('/account/~/extension/~/message-store');
            expect(Message.createUrl({}, 1)).to.equal('/account/~/extension/~/message-store/1');
            expect(Message.createUrl({ extensionId: 'foo' }, '1')).to.equal('/account/~/extension/foo/message-store/1');
            expect(Message.createUrl({
                extensionId: 'foo',
                sync: true
            }, '1')).to.equal('/account/~/extension/foo/message-sync');
            expect(Message.createUrl({ extensionId: 'foo', sms: true }, '1')).to.equal('/account/~/extension/foo/sms');
            expect(Message.createUrl({
                extensionId: 'foo',
                pager: true
            }, '1')).to.equal('/account/~/extension/foo/company-pager');
        });
    });
    describe('loadRequest, saveRequest, deleteRequest', function () {
        it('produces various urls depending on options', function () {
            expect(Message.loadRequest().url).to.equal('/account/~/extension/~/message-store');
            expect(Message.saveRequest({}).url).to.equal('/account/~/extension/~/message-store');
        });
    });
    describe('getAttachmentUrl & getAttachmentContentType', function () {
        mock.registerHooks(this);
        var platform = rcsdk.getPlatform(), message = {
            attachments: [
                {
                    uri: '/account/~/extension/~/message-store/1/attachment/---1---',
                    contentType: 'foo'
                },
                {
                    uri: '/account/~/extension/~/message-store/1/attachment/---2---',
                    contentType: 'bar'
                }
            ]
        };
        it('gives a wrapped donwloadable url, empty string if not found', function () {
            expect(Message.getAttachmentUrl(message, 0)).to.equal('http://whatever/restapi/v1.0/account/~/extension/~/message-store/1/attachment/---1---?_method=GET&access_token=' + platform.getToken());
            expect(Message.getAttachmentUrl(message, 1)).to.equal('http://whatever/restapi/v1.0/account/~/extension/~/message-store/1/attachment/---2---?_method=GET&access_token=' + platform.getToken());
            expect(Message.getAttachmentUrl(message, 2)).to.equal('');
        });
        it('gives a content type, empty string if not found', function () {
            expect(Message.getAttachmentContentType(message, 0)).to.equal('foo');
            expect(Message.getAttachmentContentType(message, 1)).to.equal('bar');
            expect(Message.getAttachmentContentType(message, 2)).to.equal('');
        });
    });
    describe('filter', function () {
        var messages = [
            {
                direction: 'Outbound',
                availability: 'Purged',
                readStatus: 'Read',
                conversationId: '1'
            },
            {
                direction: 'Inbound',
                availability: 'Deleted',
                readStatus: 'Read',
                conversationId: '1'
            },
            {
                direction: 'Outbound',
                availability: 'Alive',
                readStatus: 'Unread',
                conversationId: '2'
            },
            {
                direction: 'Outbound',
                availability: 'Alive',
                readStatus: 'Read',
                conversationId: '2',
                subject: 'foo bar baz'
            }
        ];
        it('rules out dead objects by default', function () {
            var filtered = messages.filter(Message.filter());
            expect(filtered.length).to.equal(2);
            expect(filtered[0]).to.equal(messages[2]);
            expect(filtered[1]).to.equal(messages[3]);
        });
        it('rules out objects by criteria', function () {
            var filtered;
            filtered = messages.filter(Message.filter({ alive: false }));
            expect(filtered.length).to.equal(4);
            filtered = messages.filter(Message.filter({ alive: false, direction: 'Inbound' }));
            expect(filtered.length).to.equal(1);
            expect(filtered[0]).to.equal(messages[1]);
            filtered = messages.filter(Message.filter({ alive: false, readStatus: 'Read' }));
            expect(filtered.length).to.equal(3);
            expect(filtered[0]).to.equal(messages[0]);
            expect(filtered[1]).to.equal(messages[1]);
            expect(filtered[2]).to.equal(messages[3]);
            filtered = messages.filter(Message.filter({ alive: false, conversationId: '2' }));
            expect(filtered.length).to.equal(2);
            expect(filtered[0]).to.equal(messages[2]);
            expect(filtered[1]).to.equal(messages[3]);
            filtered = messages.filter(Message.filter({ search: 'bar' }));
            expect(filtered.length).to.equal(1);
            expect(filtered[0]).to.equal(messages[3]);
        });
    });
    describe('comparator', function () {
        it('sorts by creationTime', function () {
            var messages = [
                { creationTime: '2014-08-26T09:46:06.781Z' },
                { creationTime: '2014-08-26T08:46:06.781Z' },
                { creationTime: '2014-08-26T07:46:06.781Z' }
            ];
            var sorted = [].concat(messages).sort(Message.comparator());
            expect(sorted[0]).to.equal(messages[2]);
            expect(sorted[1]).to.equal(messages[1]);
            expect(sorted[2]).to.equal(messages[0]);
        });
    });
    describe('getSubscription', function () {
        it('returns pre-configured Subscription object', function () {
            var notificaction = Message.getSubscription({ extensionId: 'foo' });
            expect(notificaction.eventFilters.length).to.equal(1);
            expect(notificaction.eventFilters[0]).to.equal('/account/~/extension/foo/message-store');
        });
    });
    describe('validate', function () {
        it('performs basic SmsMessage validation', function () {
            var res = Message.validateSMS({});
            expect(res.isValid).to.equal(false);
            expect(res.errors['to'][0]).to.be.instanceOf(Error);
            expect(res.errors['from'][0]).to.be.instanceOf(Error);
            expect(res.errors['subject'][0]).to.be.instanceOf(Error);
        });
        it('performs basic PagerMessage validation', function () {
            var res = Message.validatePager({});
            expect(res.isValid).to.equal(false);
            expect(res.errors['to'][0]).to.be.instanceOf(Error);
            expect(res.errors['from'][0]).to.be.instanceOf(Error);
            expect(res.errors['subject'][0]).to.be.instanceOf(Error);
        });
        it('passes SmsMessage validation if values are correct', function () {
            var res = Message.validateSMS({ to: [{ phoneNumber: 'foo' }], from: { phoneNumber: 'foo' }, subject: 'foo' });
            expect(res.isValid).to.equal(true);
            expect(res.errors).to.deep.equal({});
        });
        it('passes PagerMessage validation if values are correct', function () {
            var res = Message.validatePager({
                to: { extensionNumber: 'foo' },
                from: { extensionNumber: 'foo' },
                subject: 'foo'
            });
            expect(res.isValid).to.equal(true);
            expect(res.errors).to.deep.equal({});
        });
    });
});


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.dictionaries.Location', function () {
    'use strict';
    var Location = rcsdk.getLocationHelper();
    var locations = [
        { npa: '888', nxx: '222', state: { id: '1' } },
        { npa: '888', nxx: '111', state: { id: '1' } },
        { npa: '777', nxx: '111', state: { id: '2' } }
    ];
    describe('filter', function () {
        it('filters by unique NPA', function () {
            var filtered = locations.filter(Location.filter({ onlyUniqueNPA: true }));
            expect(filtered.length).to.equal(2);
            expect(filtered[0]).to.equal(locations[0]);
            expect(filtered[1]).to.equal(locations[2]);
        });
        it('filters by stateId', function () {
            var filtered = locations.filter(Location.filter({ stateId: '2' }));
            expect(filtered.length).to.equal(1);
            expect(filtered[0]).to.equal(locations[2]);
        });
    });
    describe('comparator', function () {
        it('sorts by NPA', function () {
            var sorted = [].concat(locations).sort(Location.comparator());
            expect(sorted[0]).to.equal(locations[2]);
            expect(sorted[1]).to.equal(locations[0]);
            expect(sorted[2]).to.equal(locations[1]);
        });
        it('sorts by NXX', function () {
            var sorted = [].concat(locations).sort(Location.comparator({ sortBy: 'nxx' }));
            expect(sorted[0]).to.equal(locations[2]);
            expect(sorted[1]).to.equal(locations[1]);
            expect(sorted[2]).to.equal(locations[0]);
        });
    });
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Location.createUrl()).to.equal('/dictionary/location');
        });
    });
});


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.ForwardingNumber', function () {
    'use strict';
    var ForwardingNumber = rcsdk.getForwardingNumberHelper();
    var forwardingNumbers = [
        { label: '3', phoneNumber: '1', features: ['CallForwarding', 'CallFlip'] },
        { label: '2', phoneNumber: '2', features: ['CallFlip'] },
        { label: '1', phoneNumber: '2', features: ['CallForwarding'] },
        { label: '4', phoneNumber: '2', features: [] }
    ];
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(ForwardingNumber.createUrl()).to.equal('/account/~/extension/~/forwarding-number');
            expect(ForwardingNumber.createUrl({ extensionId: 'foo' })).to.equal('/account/~/extension/foo/forwarding-number');
            expect(ForwardingNumber.createUrl({}, 'foo')).to.equal('/account/~/extension/~/forwarding-number/foo');
            expect(ForwardingNumber.createUrl({ extensionId: 'foo' }, 'bar')).to.equal('/account/~/extension/foo/forwarding-number/bar');
        });
    });
    describe('getId', function () {
        it('returns either ID or phoneNumber', function () {
            expect(ForwardingNumber.getId({ id: 'foo', phoneNumber: 'bar' })).to.equal('foo');
            expect(ForwardingNumber.getId({ phoneNumber: 'bar' })).to.equal('bar');
            expect(ForwardingNumber.getId({})).to.equal(undefined);
        });
    });
    describe('comparator', function () {
        it('sorts by label by default', function () {
            var sorted = [].concat(forwardingNumbers).sort(ForwardingNumber.comparator());
            expect(sorted[0]).to.equal(forwardingNumbers[2]);
            expect(sorted[1]).to.equal(forwardingNumbers[1]);
            expect(sorted[2]).to.equal(forwardingNumbers[0]);
        });
    });
    describe('filter', function () {
        it('provides functionality to filter by feature', function () {
            var filtered = [];
            filtered = forwardingNumbers.filter(ForwardingNumber.filter({ features: ['CallForwarding', 'CallFlip'] }));
            expect(filtered.length).to.equal(3);
            expect(filtered[0]).to.equal(forwardingNumbers[0]);
            expect(filtered[1]).to.equal(forwardingNumbers[1]);
            expect(filtered[2]).to.equal(forwardingNumbers[2]);
            filtered = forwardingNumbers.filter(ForwardingNumber.filter({ features: ['CallForwarding'] }));
            expect(filtered[0]).to.equal(forwardingNumbers[0]);
            expect(filtered[1]).to.equal(forwardingNumbers[2]);
        });
    });
});


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Extension', function () {
    'use strict';
    var Extension = rcsdk.getExtensionHelper();
    var extensions = [
        { name: 'One One One', extensionNumber: 111, type: 'foo' },
        { name: 'Twenty One', extensionNumber: 21, type: 'bar' }
    ];
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Extension.createUrl()).to.equal('/account/~/extension');
            expect(Extension.createUrl({}, 'foo')).to.equal('/account/~/extension/foo');
            expect(Extension.createUrl({ departmentId: 'foo' })).to.equal('/account/~/department/foo/members');
            expect(Extension.createUrl({ departmentId: 'foo' }, 'bar')).to.equal('/account/~/department/foo/members/bar');
        });
    });
    describe('comparator', function () {
        it('allows to sort extensions by extensionNumber', function () {
            var exts = [].concat(extensions).sort(Extension.comparator());
            expect(exts[0]).to.equal(extensions[1]);
            expect(exts[1]).to.equal(extensions[0]);
        });
    });
    describe('filter', function () {
        it('allows to filter extensions by name and extensionNumber', function () {
            expect(extensions.filter(Extension.filter({ search: 'One' })).length).to.equal(2);
            expect(extensions.filter(Extension.filter({ search: '21' })).length).to.equal(1);
        });
        it('allows to filter extensions by type', function () {
            expect(extensions.filter(Extension.filter({ type: 'foo' })).length).to.equal(1);
        });
    });
    describe('convenience methods', function () {
        it('provides type detection', function () {
            expect(Extension.isUser()).to.equal(undefined);
            expect(Extension.isDepartment()).to.equal(undefined);
            expect(Extension.isAnnouncement()).to.equal(undefined);
            expect(Extension.isVoicemail()).to.equal(undefined);
            expect(Extension.isUser({ type: 'foo' })).to.equal(false);
            expect(Extension.isDepartment({ type: 'foo' })).to.equal(false);
            expect(Extension.isAnnouncement({ type: 'foo' })).to.equal(false);
            expect(Extension.isVoicemail({ type: 'foo' })).to.equal(false);
            expect(Extension.isUser({ type: 'User' })).to.equal(true);
            expect(Extension.isDepartment({ type: 'Department' })).to.equal(true);
            expect(Extension.isAnnouncement({ type: 'Announcement' })).to.equal(true);
            expect(Extension.isVoicemail({ type: 'Voicemail' })).to.equal(true);
        });
    });
});


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.dictionaries.DeviceModel', function () {
    'use strict';
    var DeviceModel = rcsdk.getDeviceModelHelper();
    describe('getId', function () {
        it('provides artificial IDs', function () {
            expect(DeviceModel.getId({
                sku: '23',
                name: 'Polycom IP 321 Basic IP phone',
                deviceClass: 'Desk Phone'
            })).to.equal('23');
        });
    });
});


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Device', function () {
    'use strict';
    var Device = rcsdk.getDeviceHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Device.createUrl()).to.equal('/account/~/device');
            expect(Device.createUrl({}, 'foo')).to.equal('/account/~/device/foo');
            expect(Device.createUrl({ extensionId: 'foo' })).to.equal('/account/~/extension/foo/device');
            expect(Device.createUrl({ extensionId: 'foo' }, 'bar')).to.equal('/account/~/extension/foo/device/bar');
            expect(Device.createUrl({ order: true }, 'bar')).to.equal('/account/~/order');
        });
    });
    describe('validate', function () {
        it('performs basic validation', function () {
            var res = Device.validate({});
            expect(res.isValid).to.equal(false);
            expect(res.errors['emergencyServiceAddress-street'][0]).to.be.instanceOf(Error);
            expect(res.errors['emergencyServiceAddress-city'][0]).to.be.instanceOf(Error);
            expect(res.errors['emergencyServiceAddress-state'][0]).to.be.instanceOf(Error);
            expect(res.errors['emergencyServiceAddress-country'][0]).to.be.instanceOf(Error);
            expect(res.errors['emergencyServiceAddress-zip'][0]).to.be.instanceOf(Error);
            expect(res.errors['emergencyServiceAddress-customerName'][0]).to.be.instanceOf(Error);
            expect(res.errors['extension'][0]).to.be.instanceOf(Error);
            expect(res.errors['model'][0]).to.be.instanceOf(Error);
        });
        it('passes validation if values are correct', function () {
            var res = Device.validate({
                emergencyServiceAddress: {
                    street: 'foo',
                    city: 'foo',
                    state: 'foo',
                    country: 'foo',
                    zip: 'foo',
                    customerName: 'foo'
                },
                extension: { id: 'foo' },
                model: { sku: 'foo' }
            });
            expect(res.isValid).to.equal(true);
            expect(res.errors).to.deep.equal({});
        });
    });
});


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.dictionaries.Country', function () {
    'use strict';
    var Country = rcsdk.getCountryHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Country.createUrl()).to.equal('/dictionary/country');
        });
    });
});


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.ContactGroup', function () {
    'use strict';
    var ContactGroup = rcsdk.getContactGroupHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(ContactGroup.createUrl()).to.equal('/account/~/extension/~/address-book/group');
            expect(ContactGroup.createUrl({}, 'foo')).to.equal('/account/~/extension/~/address-book/group/foo');
        });
    });
    describe('validate', function () {
        it('performs basic validation', function () {
            var res = ContactGroup.validate({});
            expect(res.isValid).to.equal(false);
            expect(res.errors['groupName'][0]).to.be.instanceOf(Error);
            expect(res.errors['groupName'].length).to.equal(1);
        });
        it('passes validation if values are correct', function () {
            var res = ContactGroup.validate({ groupName: 'foo' });
            expect(res.isValid).to.equal(true);
            expect(res.errors).to.deep.equal({});
        });
    });
});


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Contact', function () {
    'use strict';
    var Contact = rcsdk.getContactHelper();
    describe('match & matchAsPhone', function () {
        it('matches a string against a contact', function () {
            var contact = {
                firstName: 'firstName',
                lastName: 'lastName',
                company: 'lastName',
                nickName: 'lastName',
                middleName: 'lastName',
                email: 'lastName',
                email2: 'lastName',
                email3: 'lastName',
                homePhone: '+homePhone',
                homePhone2: 'lastName',
                businessPhone: 'lastName',
                businessPhone2: 'lastName',
                mobilePhone: 'lastName',
                companyPhone: 'lastName',
                assistantPhone: 'lastName',
                carPhone: 'lastName',
                otherPhone: 'lastName',
                callbackPhone: 'lastName',
                businessFax: 'lastName',
                otherFax: 'lastName',
                businessAddress: {
                    country: 'businessAddress-street',
                    street: 'businessAddress-street',
                    city: 'businessAddress-city',
                    state: 'businessAddress-state',
                    zip: 'businessAddress-zip'
                },
                homeAddress: {
                    country: 'homeAddress-street',
                    street: 'homeAddress-street',
                    city: 'homeAddress-city',
                    state: 'homeAddress-state',
                    zip: 'homeAddress-zip'
                },
                otherAddress: {
                    country: 'otherAddress-street',
                    street: 'otherAddress-street',
                    city: 'otherAddress-city',
                    state: 'otherAddress-state',
                    zip: 'otherAddress-zip'
                }
            };
            expect(Contact.match(contact, 'firstName')).to.equal(contact.firstName);
            expect(Contact.match(contact, 'lastName')).to.equal(contact.lastName);
            expect(Contact.matchAsPhone(contact, 'homePhone')).to.equal(contact.homePhone);
            expect(Contact.matchAsPhone(contact, 'businessAddress-street')).to.equal(null);
            // search in address
            expect(Contact.match(contact, 'businessAddress-street')).to.equal(contact.businessAddress.street);
            expect(Contact.match(contact, 'businessAddress-street', { inAddresses: false })).to.equal(null);
        });
    });
    describe('attachContacts', function () {
        it('provides corresponding contacts to callerInfo objects', function () {
            var contacts = [
                { homePhone: '+(1)foo' },
                { homePhone: '+(1)foo' },
                { homePhone: '+(2)bar' }
            ], callerInfos = [
                { phoneNumber: '2bar' },
                { phoneNumber: '1foo' },
                { phoneNumber: 'notfound' }
            ];
            Contact.attachToCallerInfos(callerInfos, contacts);
            expect(callerInfos[0].contact).to.equal(contacts[2]);
            expect(callerInfos[0].contactPhone).to.equal(contacts[2].homePhone);
            // first contact must win
            expect(callerInfos[1].contact).to.equal(contacts[0]);
            expect(callerInfos[1].contactPhone).to.equal(contacts[0].homePhone);
            expect(callerInfos[1].contact).to.not.equal(contacts[1]);
            expect(callerInfos[2].contact).to.be.an('undefined');
            expect(callerInfos[2].contact).to.be.an('undefined');
            expect(callerInfos[2].contactPhone).to.be.an('undefined');
        });
    });
    describe('filter', function () {
        var contacts = [
            { lastName: 'unavailable', availability: 'Purged' },
            { firstName: 'foo', availability: 'Alive' },
            { lastName: 'foo', businessFax: 'foo', availability: 'Alive' },
            { homePhone: 'foo', availability: 'Alive' }
        ];
        it('rules out dead objects by default', function () {
            var filtered = contacts.filter(Contact.filter());
            expect(filtered.length).to.equal(3);
            expect(filtered[0]).to.equal(contacts[1]);
            expect(filtered[1]).to.equal(contacts[2]);
            expect(filtered[2]).to.equal(contacts[3]);
        });
        it('rules out by search phrase', function () {
            var filtered = contacts.filter(Contact.filter({ startsWith: 'foo' }));
            expect(filtered.length).to.equal(3);
            expect(filtered[0]).to.equal(contacts[1]);
            expect(filtered[1]).to.equal(contacts[2]);
            expect(filtered[2]).to.equal(contacts[3]);
        });
        it('rules out by items with no phones', function () {
            var filtered = contacts.filter(Contact.filter({ phonesOnly: true }));
            expect(filtered.length).to.equal(1);
            expect(filtered[0]).to.equal(contacts[3]);
        });
        it('rules out by items with no faxes', function () {
            var filtered = contacts.filter(Contact.filter({ faxesOnly: true }));
            expect(filtered.length).to.equal(1);
            expect(filtered[0]).to.equal(contacts[2]);
        });
    });
    describe('comparator', function () {
        var contacts = [
            { lastName: 'b' },
            { firstName: 'b' },
            { firstName: 'a' }
        ];
        it('sorts objects by "full name"', function () {
            var sorted = [].concat(contacts).sort(Contact.comparator());
            expect(sorted[0]).to.equal(contacts[2]);
            expect(sorted[1]).to.equal(contacts[0]);
            expect(sorted[2]).to.equal(contacts[1]);
        });
    });
    describe('validate', function () {
        it('performs basic validation', function () {
            var res = Contact.validate({});
            expect(res.isValid).to.equal(false);
            expect(res.errors['firstName'][0]).to.be.instanceOf(Error);
            expect(res.errors['lastName'][0]).to.be.instanceOf(Error);
            expect(res.errors['email']).to.be.an('undefined');
            expect(res.errors['email2']).to.be.an('undefined');
            expect(res.errors['email3']).to.be.an('undefined');
        });
        it('performs complex validation', function () {
            var res = Contact.validate({ email: 'foo', email2: 'bar', email3: 'baz' });
            expect(res.isValid).to.equal(false);
            expect(res.errors['firstName'][0]).to.be.instanceOf(Error);
            expect(res.errors['lastName'][0]).to.be.instanceOf(Error);
            expect(res.errors['email'][0]).to.be.instanceOf(Error);
            expect(res.errors['email2'][0]).to.be.instanceOf(Error);
            expect(res.errors['email3'][0]).to.be.instanceOf(Error);
        });
        it('passes validation if values are correct', function () {
            var res = Contact.validate({
                email: 'foo@bar.baz',
                email2: 'foo@bar.baz',
                email3: 'foo@bar.baz',
                firstName: 'foo',
                lastName: 'bar'
            });
            expect(res.isValid).to.equal(true);
            expect(res.errors).to.deep.equal({});
        });
        it('passes validation if values are correct', function () {
            var res = Contact.validate({
                firstName: 'foo',
                lastName: 'bar'
            });
            expect(res.isValid).to.equal(true);
            expect(res.errors).to.deep.equal({});
        });
    });
});


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Conferencing', function () {
    'use strict';
    var Conferencing = rcsdk.getConferencingHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Conferencing.createUrl()).to.equal('/account/~/extension/~/conferencing');
        });
    });
});


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Call', function () {
    'use strict';
    var Call = rcsdk.getCallHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Call.createUrl()).to.equal('/account/~/extension/~/call-log');
            expect(Call.createUrl({ personal: true })).to.equal('/account/~/extension/~/call-log');
            expect(Call.createUrl({ extensionId: '12345' })).to.equal('/account/~/extension/12345/call-log');
            expect(Call.createUrl({ extensionId: '12345' }, '67890')).to.equal('/account/~/extension/12345/call-log/67890');
            expect(Call.createUrl({ active: true })).to.equal('/account/~/extension/~/active-calls');
            expect(Call.createUrl({ active: true, personal: true })).to.equal('/account/~/extension/~/active-calls');
            expect(Call.createUrl({ active: true }, 'foo')).to.equal('/account/~/extension/~/active-calls/foo');
            expect(Call.createUrl({
                active: true,
                extensionId: 'bar'
            }, 'foo')).to.equal('/account/~/extension/bar/active-calls/foo');
        });
    });
    describe('attachContacts', function () {
        it('attaches contacts to all callerInfo structures found in each call', function () {
            var contacts = [
                { id: 'foo', homePhone: 'foo' },
                { id: 'bar', homePhone: 'bar' },
                { id: 'baz', homePhone: 'baz' }
            ], calls = [
                {
                    direction: 'Outbound',
                    from: { phoneNumber: 'foo' },
                    to: { phoneNumber: 'bar' }
                },
                {
                    direction: 'Inbound',
                    from: { phoneNumber: 'baz' },
                    to: { phoneNumber: 'notfound' }
                }
            ];
            Call.attachContacts(contacts, calls);
            expect(calls[0].from.contact).to.equal(contacts[0]);
            expect(calls[0].to.contact).to.equal(contacts[1]);
            expect(calls[1].from.contact).to.equal(contacts[2]);
            expect(calls[1].to.contact).to.be.an('undefined');
        });
    });
    describe('getCallerInfo', function () {
        var calls = [
            {
                direction: 'Outbound',
                from: { phoneNumber: 'foo' },
                to: { phoneNumber: 'bar' }
            },
            {
                direction: 'Inbound',
                from: { phoneNumber: 'baz' },
                to: { phoneNumber: 'qux' }
            }
        ];
        it('returns callerInfo of from or to properties depending on direction', function () {
            expect(Call.getCallerInfo(calls[0]).phoneNumber).to.equal('bar');
            expect(Call.getCallerInfo(calls[1]).phoneNumber).to.equal('baz');
        });
        it('returms all callerInfos in an order depending on direction', function () {
            expect(Call.getAllCallerInfos(calls[0])[0].phoneNumber).to.equal('bar');
            expect(Call.getAllCallerInfos(calls[0])[1].phoneNumber).to.equal('foo');
            expect(Call.getAllCallerInfos(calls[1])[0].phoneNumber).to.equal('baz');
            expect(Call.getAllCallerInfos(calls[1])[1].phoneNumber).to.equal('qux');
        });
    });
    describe('formatDuration', function () {
        it('formats duration', function () {
            expect(Call.formatDuration({ duration: 0.5 })).to.equal('00:00');
            expect(Call.formatDuration({ duration: 0 })).to.equal('00:00');
            expect(Call.formatDuration({ duration: 1 })).to.equal('00:01');
            expect(Call.formatDuration({ duration: 1.5 })).to.equal('00:01');
            expect(Call.formatDuration({ duration: 10 })).to.equal('00:10');
            expect(Call.formatDuration({ duration: 60 })).to.equal('01:00');
            expect(Call.formatDuration({ duration: 70 })).to.equal('01:10');
            expect(Call.formatDuration({ duration: 60 * 60 })).to.equal('1:00:00');
            expect(Call.formatDuration({ duration: 60 * 60 * 10 + 70 })).to.equal('10:01:10');
        });
    });
    var calls = [
        { type: 'Voice', direction: 'Inbound', startTime: '2014-08-26T09:46:06.781Z' },
        { type: 'Voice', direction: 'Outbound', startTime: '2014-08-26T08:46:06.781Z' },
        { type: 'Voip', direction: 'Inbound', startTime: '2014-08-26T07:46:06.781Z' },
        { type: 'Voip', direction: 'Outbound', startTime: '2014-08-26T06:46:06.781Z' }
    ];
    describe('filter', function () {
        it('allows to filter calls by type and direction', function () {
            expect(calls.filter(Call.filter({ type: 'Voice', direction: 'Inbound' })).length).to.equal(1);
            expect(calls.filter(Call.filter({ type: 'Voice' })).length).to.equal(2);
            expect(calls.filter(Call.filter({ direction: 'Inbound' })).length).to.equal(2);
        });
    });
    describe('sort', function () {
        it('allows to sort calls by startTime by default', function () {
            var sorted = [].concat(calls).sort(Call.comparator());
            expect(sorted[0]).to.equal(calls[3]);
            expect(sorted[1]).to.equal(calls[2]);
            expect(sorted[2]).to.equal(calls[1]);
            expect(sorted[3]).to.equal(calls[0]);
        });
    });
    var mocks = {
        initial: {
            presence: {
                "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/presence",
                "extension": {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321",
                    "id": 62480591,
                    "extensionNumber": "4166"
                },
                "presenceStatus": "Available",
                "telephonyStatus": "NoCall",
                "userStatus": "Available",
                "dndStatus": "TakeAllCalls",
                "message": "Waka waka",
                "allowSeeMyPresence": true,
                "ringOnMonitoredCall": false,
                "pickUpCallsOnHold": false
            },
            activeCalls: [],
            calls: [
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iTLeNN-expL4g",
                    "id": "B0iTLeNN-expL4g",
                    "sessionId": "88052061020",
                    "startTime": "2014-12-11T00:48:08.000Z",
                    "duration": 11,
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "Accepted",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                },
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iNkuy10B0FLG0",
                    "id": "B0iNkuy10B0FLG0",
                    "sessionId": "88051027020",
                    "startTime": "2014-12-11T00:40:13.000Z",
                    "duration": 11,
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "Accepted",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                }
            ]
        },
        ringing: {
            presence: {
                "extensionId": 62480591,
                "telephonyStatus": "Ringing",
                "activeCalls": [
                    {
                        "id": "1e8b5e8847924ab49f383bc8d355ee33",
                        "direction": "Inbound",
                        "from": "1650CALLER0",
                        "to": "1855COMPANY",
                        "telephonyStatus": "Ringing",
                        "sessionId": "88052513020"
                    }
                ],
                "sequence": 7272442
            },
            activeCalls: [
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iVoSn2fxQRMMM",
                    "id": "B0iVoSn2fxQRMMM",
                    "sessionId": "88052513020",
                    "startTime": "2014-12-11T00:51:23.000Z",
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "In Progress",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" },
                    wayToDetermineOverwrite: true
                }
            ],
            calls: [
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iVoSn2fxQRMMM",
                    "id": "B0iVoSn2fxQRMMM",
                    "sessionId": "88052513020",
                    "startTime": "2014-12-11T00:51:23.000Z",
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "In Progress",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" },
                    wayToDetermineItsACall: true
                },
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iTLeNN-expL4g",
                    "id": "B0iTLeNN-expL4g",
                    "sessionId": "88052061020",
                    "startTime": "2014-12-11T00:48:08.000Z",
                    "duration": 11,
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "Accepted",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                },
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iNkuy10B0FLG0",
                    "id": "B0iNkuy10B0FLG0",
                    "sessionId": "88051027020",
                    "startTime": "2014-12-11T00:40:13.000Z",
                    "duration": 11,
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "Accepted",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                }
            ]
        },
        pickup: {
            presence: {
                "extensionId": 62480591,
                "telephonyStatus": "CallConnected",
                "activeCalls": [
                    {
                        "id": "1e8b5e8847924ab49f383bc8d355ee33",
                        "direction": "Inbound",
                        "from": "1650CALLER0",
                        "to": "1855COMPANY",
                        "telephonyStatus": "CallConnected",
                        "sessionId": "88052513020"
                    }
                ],
                "sequence": 7272469
            },
            activeCalls: [
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iVoSn2fxQRMMM",
                    "id": "B0iVoSn2fxQRMMM",
                    "sessionId": "88052513020",
                    "startTime": "2014-12-11T00:51:23.000Z",
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "In Progress",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                }
            ],
            calls: [
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iVoSn2fxQRMMM",
                    "id": "B0iVoSn2fxQRMMM",
                    "sessionId": "88052513020",
                    "startTime": "2014-12-11T00:51:23.000Z",
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "In Progress",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                },
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iTLeNN-expL4g",
                    "id": "B0iTLeNN-expL4g",
                    "sessionId": "88052061020",
                    "startTime": "2014-12-11T00:48:08.000Z",
                    "duration": 11,
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "Accepted",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                },
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iNkuy10B0FLG0",
                    "id": "B0iNkuy10B0FLG0",
                    "sessionId": "88051027020",
                    "startTime": "2014-12-11T00:40:13.000Z",
                    "duration": 11,
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "Accepted",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                }
            ]
        },
        hangup: {
            presence: {
                "extensionId": 62480591,
                "telephonyStatus": "NoCall",
                "activeCalls": [
                    {
                        "id": "1e8b5e8847924ab49f383bc8d355ee33",
                        "direction": "Inbound",
                        "from": "1650CALLER0",
                        "to": "1855COMPANY",
                        "telephonyStatus": "NoCall",
                        "sessionId": "88052513020"
                    }
                ],
                "sequence": 7272495
            },
            activeCalls: [],
            calls: [
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iVoSn2fxQRMMQ",
                    "id": "B0iVoSn2fxQRMMQ",
                    "sessionId": "88052513020",
                    "startTime": "2014-12-11T00:51:24.000Z",
                    "duration": 42,
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "Accepted",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                },
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iTLeNN-expL4g",
                    "id": "B0iTLeNN-expL4g",
                    "sessionId": "88052061020",
                    "startTime": "2014-12-11T00:48:08.000Z",
                    "duration": 11,
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "Accepted",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                },
                {
                    "uri": "https://api.ringcentral.com/restapi/v1.0/account/123/extension/321/call-log/B0iNkuy10B0FLG0",
                    "id": "B0iNkuy10B0FLG0",
                    "sessionId": "88051027020",
                    "startTime": "2014-12-11T00:40:13.000Z",
                    "duration": 11,
                    "type": "Voice",
                    "direction": "Inbound",
                    "action": "Phone Call",
                    "result": "Accepted",
                    "to": { "phoneNumber": "1855COMPANY", "name": "Called Ext Name" },
                    "from": { "phoneNumber": "1650CALLER0", "name": "Called Ext Name", "location": "San Mateo, CA" }
                }
            ]
        }
    };
    describe('mergePresenceCalls', function () {
        it('merges known presence calls', function (done) {
            var presenceCalls = [];
            presenceCalls = Call.mergePresenceCalls(presenceCalls, mocks.initial.presence);
            presenceCalls = Call.mergePresenceCalls(presenceCalls, mocks.ringing.presence);
            expect(presenceCalls.length).to.equal(1);
            expect(presenceCalls[0].startTime).to.not.equal('');
            expect(presenceCalls[0].result).to.equal('In Progress');
            var oldTime = presenceCalls[0].startTime;
            setTimeout(function () {
                presenceCalls = Call.mergePresenceCalls(presenceCalls, mocks.pickup.presence);
                expect(presenceCalls.length).to.equal(1);
                expect(presenceCalls[0].startTime).to.equal(oldTime);
                done();
            }, 10);
        });
        it('sets appropriate statuses', function (done) {
            var presenceCalls = Call.mergePresenceCalls([], mocks.initial.presence);
            presenceCalls = Call.mergePresenceCalls(presenceCalls, mocks.ringing.presence);
            expect(presenceCalls[0].result).to.equal('In Progress');
            expect(presenceCalls[0].telephonyStatus).to.equal('Ringing');
            setTimeout(function () {
                presenceCalls = Call.mergePresenceCalls(presenceCalls, mocks.pickup.presence);
                expect(presenceCalls[0].result).to.equal('In Progress');
                expect(presenceCalls[0].telephonyStatus).to.equal('CallConnected');
            }, 10);
            setTimeout(function () {
                presenceCalls = Call.mergePresenceCalls(presenceCalls, mocks.hangup.presence);
                expect(presenceCalls[0].result).to.equal('NoCall');
                expect(presenceCalls[0].telephonyStatus).to.equal('NoCall');
                done();
            }, 20);
        });
    });
    describe('mergeAll', function () {
        it('merges together calls from presence, active calls, calls', function () {
            var presenceCalls = Call.mergePresenceCalls([], mocks.ringing.presence), allCalls = Call.mergeAll(presenceCalls, mocks.ringing.calls, mocks.ringing.activeCalls)
                .sort(Call.comparator())
                .reverse();
            expect(allCalls.length).to.equal(3);
            expect(allCalls[0].result).to.equal('In Progress');
            expect(allCalls[0].wayToDetermineItsACall).to.equal(true);
            expect(allCalls[0].wayToDetermineOverwrite).to.equal(true);
        });
    });
});


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.BlockedNumber', function () {
    'use strict';
    var BlockedNumber = rcsdk.getBlockedNumberHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(BlockedNumber.createUrl()).to.equal('/account/~/extension/~/blocked-number');
            expect(BlockedNumber.createUrl({ extensionId: 'foo' })).to.equal('/account/~/extension/foo/blocked-number');
            expect(BlockedNumber.createUrl({ extensionId: 'foo' }, 'bar')).to.equal('/account/~/extension/foo/blocked-number/bar');
        });
    });
});


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.helpers.Account', function () {
    'use strict';
    var Account = rcsdk.getAccountHelper();
    describe('createUrl', function () {
        it('returns URL depending on options', function () {
            expect(Account.createUrl()).to.equal('/account/~');
        });
    });
});


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.core.Validator', function () {
    var Validator = rcsdk.getValidator();
    describe('length', function () {
        function lengthValidator(description, max, min, valueToTest, expectedValidationResult) {
            it(description, function () {
                var result = Validator.validate([{ field: 'foo', validator: Validator.length(valueToTest, max, min) }]);
                expect(result.isValid).to.equal(expectedValidationResult);
            });
        }
        describe('positive tests', function () {
            lengthValidator('should validate a length that is equal to the max length', 9, 2, '123456789', true);
            lengthValidator('should validate a length that is equal to the min length', 9, 2, '12', true);
            lengthValidator('should validate a length that is between the max and min length', 9, 2, '12345', true);
            lengthValidator('should treat a falsey max as meaning there is no max length', null, 2, '123456789abcdef', true);
            lengthValidator('should treat a falsey min as meaning there is no min length', 9, null, '', true);
        });
        describe('negative tests', function () {
            lengthValidator('should not validate a length that is above the max length', 5, 4, '123456', false);
            lengthValidator('should not validate a length that is below the min length', 5, 4, '123', false);
        });
    });
});


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.core.Utils', function () {
    'use strict';
    var Utils = rcsdk.getUtils();
    describe('parseQueryString & queryStringify', function () {
        it('parses queryStrings', function () {
            expect(Utils.parseQueryString('foo=bar&bar=baz')).to.deep.equal({ foo: 'bar', bar: 'baz' });
            expect(Utils.parseQueryString('foo=bar&foo=baz')).to.deep.equal({ foo: ['bar', 'baz'] });
            expect(Utils.parseQueryString('foo')).to.deep.equal({ foo: true });
        });
        it('builds queryStrings', function () {
            expect(Utils.queryStringify({ foo: 'bar', bar: 'baz' })).to.equal('foo=bar&bar=baz');
            expect(Utils.queryStringify({ foo: ['bar', 'baz'] })).to.equal('foo=bar&foo=baz');
        });
        it('decodes pre-encoded string representation of object to be equal to original object', function () {
            function encodeDecode(v) {
                return Utils.parseQueryString(Utils.queryStringify(v));
            }
            var simple = { foo: 'bar' }, array = { foo: ['bar', 'baz'] };
            expect(encodeDecode(simple)).to.deep.equal(simple);
            expect(encodeDecode(array)).to.deep.equal(array);
        });
    });
    describe('extend', function () {
        it('applies properties of sources to target (only first level)', function () {
            var target = {
                foo: {
                    id: 0,
                    name: 'name'
                }
            }, source1 = {
                foo: {
                    id: 1
                },
                bar: {
                    id: 1
                }
            }, source2 = {
                foo: {
                    id: 2
                }
            }, result = Utils.extend(target, source1, source2);
            // make sure result is target
            expect(result).to.equal(target);
            // make sure source2 has overrided source1 and target
            expect(result.foo.id).to.equal(2);
            expect(result.foo.name).to.be.an('undefined');
            // make sure other properties of source 1 are copied
            expect(result.bar.id).to.equal(1);
        });
        it('applies all properties of sources to target in deep mode', function () {
            var target = {
                foo: {
                    id: 0,
                    name: 'name'
                }
            }, source1 = {
                foo: {
                    id: 1
                },
                bar: {
                    id: 1
                }
            }, source2 = {
                foo: {
                    id: 2
                }
            }, result = Utils.extend(true, target, source1, source2);
            // make sure result is target
            expect(result).to.equal(target);
            // make sure original target properties that does not exist in sources are still available
            expect(result.foo.name).to.equal('name');
            // make sure source2 has overrided source1 and target
            expect(result.foo.id).to.equal(2);
            // make sure other properties of source 1 are copied
            expect(result.bar.id).to.equal(1);
        });
        it('copies all kinds of values', function () {
            var target = {
                'array': []
            }, source = {
                'object': {
                    bar: {
                        baz: 'baz'
                    }
                },
                'null': null,
                'array': [1, 2, 3],
                'date': new Date(),
                'string': 'string'
            };
            Utils.extend(true, target, source);
            // Deep equality
            expect(target).to.deep.equal(source);
            // Dates are linked
            expect(target.date).to.equal(source.date);
            // Arrays are cloned
            expect(target.array).not.to.equal(source.array);
        });
    });
    describe('poll & stopPolling', function () {
        it('allows to set custom delay', function (done) {
            Utils.poll(function (next, delay) {
                expect(delay).to.equal(10);
                done();
            }, 10);
        });
        it('provides a method to do it continuously', function (done) {
            var i = 0;
            Utils.poll(function (next) {
                i++;
                if (i < 3)
                    next();
                else
                    done();
            }, 1);
            after(function () {
                expect(i).to.equal(3);
            });
        });
        it('provides a method stop', function (done) {
            var timeout = Utils.poll(function (next) {
                done(new Error('This should never be reached'));
            }, 10);
            Utils.stopPolling(timeout);
            done();
        });
        it('cancels a previous timeout if provided', function (done) {
            var timeout = Utils.poll(function (next) {
                done(new Error('This should never be reached'));
            }, 10);
            var timeout2 = Utils.poll(function (next) {
                done();
            }, 10, timeout);
        });
    });
    describe('parseNumber', function () {
        it('extracts object itself as number if no options given', function () {
            expect(Utils.parseNumber(1)).to.equal(1);
            expect(Utils.parseNumber('1')).to.equal(1);
            expect(Utils.parseNumber('0')).to.equal(0);
            expect(Utils.parseNumber([])).to.equal(0);
            expect(Utils.parseNumber([1])).to.equal(1);
            expect(Utils.parseNumber([1, 1])).to.equal(1);
            expect(Utils.parseNumber('not-a-number')).to.equal(0);
            expect(Utils.parseNumber(null)).to.equal(0);
        });
    });
    describe('stringExtractor', function () {
        it('extracts object itself as string if no options given', function () {
            expect(Utils.parseString(1)).to.equal('1');
            expect(Utils.parseString(0)).to.equal('');
            expect(Utils.parseString([])).to.equal('');
            expect(Utils.parseString([1, 2])).to.equal('1,2');
            expect(Utils.parseString(null)).to.equal('');
            expect(Utils.parseString({})).to.equal('[object Object]');
        });
    });
    describe('isEmail', function () {
        function emailValidator(description, multiple, valueToTest, expectedValidationResult) {
            it(description, function () {
                expect(Utils.isEmail(valueToTest, multiple)).to.equal(expectedValidationResult);
            });
        }
        describe('positive tests', function () {
            emailValidator('should validate simple addresses', false, 'foo@bar.com', true);
            emailValidator('should validate addresses with digits', false, '123@456.789', true);
            emailValidator('should validate addresses with special characters', false, '!#$%&\'*+/=?^_`{|}~-@qux.com', true);
            emailValidator('should validate addresses with multiple host segments', false, 'foo@bar.baz.qux.com', true);
            emailValidator('should validate multiple addresses when true is specified for the multiple constructor argument', true, 'foo@bar.com; baz@qux.com', true);
        });
        describe('negative tests', function () {
            emailValidator('should not validate addresses with multiple @ symbols', false, 'foo@bar@baz.com', false);
            emailValidator('should not validate addresses with invalid characters', false, 'foo bar@baz.com', false);
            emailValidator('should not validate addresses with malformed host segment', false, 'foo@bar.baz.', false);
            emailValidator('should not validate addresses with missing host segment', false, 'foo@', false);
            emailValidator('should not validate multiple addresses when false is specified for the multiple constructor argument', false, 'foo@bar.com; baz@qux.com', false);
        });
    });
    describe('isPhone', function () {
        function phoneValidator(description, valueToTest, expectedValidationResult) {
            it(description, function () {
                expect(Utils.isPhoneNumber(valueToTest)).to.equal(expectedValidationResult);
            });
        }
        describe('positive tests', function () {
            phoneValidator('should validate a phone number with no formatting characters', '16501234567', true);
            phoneValidator('should validate a phone number with typical formatting characters', '1 (650) 123-4567', true);
            phoneValidator('should validate a phone number with periods as digit separators', '1.650.123.4567', true);
            phoneValidator('should validate a phone number with optional + prefix', '+1 650 123 4567', true);
            phoneValidator('should validate a vanity phone number', '+1 800 FOR HELP', true);
        });
        describe('negative tests', function () {
            phoneValidator('should not validate a phone number that is missing the country code', '(650) 123-4567', false);
            phoneValidator('should not validate a phone number that has too few digits', '1 (650) 123-456', false);
            phoneValidator('should not validate a phone number with letters in area code', '+1 FOO FOR HELP', false);
        });
    });
    describe('is*', function () {
        describe('isDate', function () {
            expect(Utils.isDate(new Date())).to.equal(true);
        });
        describe('isFunction', function () {
            expect(Utils.isFunction(Date)).to.equal(true);
            expect(Utils.isFunction(function () { })).to.equal(true);
        });
        describe('isArray', function () {
            expect(Utils.isArray([])).to.equal(true);
        });
        describe('isNaN', function () {
            expect(Utils.isNaN(NaN)).to.equal(true);
        });
    });
    describe('getProperty', function () {
        it('returns a nested property', function () {
            var foo = {
                bar: {
                    baz: 'qux'
                },
                arr: ['zero', 'one', 'two', { foo: 'bar' }]
            };
            expect(Utils.getProperty(foo, 'bar.baz')).to.equal('qux');
            expect(Utils.getProperty(foo, 'arr[0]')).to.equal('zero');
            expect(Utils.getProperty(foo, 'arr[1]')).to.equal('one');
            expect(Utils.getProperty(foo, 'arr[3].foo')).to.equal('bar');
            expect(Utils.getProperty(foo, 'nonexistent')).to.equal(undefined);
        });
    });
});


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.core.Subscription', function () {
    mock.registerHooks(this);
    describe('subscribe', function () {
        it('automatically renews subscription', function (done) {
            mock.subscribeGeneric(60);
            var subscription = rcsdk.getSubscription();
            subscription.on(subscription.events.renewSuccess, function () {
                subscription.destroy(); // prevent next renewals
                done();
            });
            subscription
                .register({
                events: ['foo', 'bar']
            })
                .then(function (ajax) {
                expect(ajax.data.expiresIn).to.equal(60);
            })
                .catch(done);
        });
    });
    describe.skip('destroy', function () { });
    describe('notify method', function () {
        it('fires a notification event when the notify method is called and passes the message object', function (done) {
            var subscription = rcsdk.getSubscription();
            subscription.on(subscription.events.notification, function (event) {
                expect(event).to.deep.equal({ foo: 'bar' });
                done();
            });
            subscription.notify({ foo: 'bar' });
        });
    });
    describe('renew', function () {
        it('fails when no subscription', function (done) {
            var subscription = rcsdk.getSubscription();
            subscription
                .renew()
                .then(function () {
                done(new Error('This should not be reached'));
            })
                .catch(function (e) {
                expect(e.message).to.equal('Subscription ID is required');
                done();
            });
        });
        it('fails when no eventFilters', function (done) {
            var subscription = rcsdk.getSubscription();
            subscription.subscription = { id: 'foo' };
            subscription
                .renew()
                .then(function () {
                done(new Error('This should not be reached'));
            })
                .catch(function (e) {
                expect(e.message).to.equal('Events are undefined');
                done();
            });
        });
    });
    describe('subscribe', function () {
        it('fails when no eventFilters', function (done) {
            var subscription = rcsdk.getSubscription();
            subscription
                .subscribe()
                .then(function () {
                done(new Error('This should not be reached'));
            })
                .catch(function (e) {
                expect(e.message).to.equal('Events are undefined');
                done();
            });
        });
        it('calls the success callback and passes the subscription provided from the platform', function (done) {
            var event = 'foo';
            var subscription = rcsdk.getSubscription();
            mock.subscribeGeneric();
            subscription
                .subscribe({
                events: [event]
            })
                .then(function () {
                expect(subscription.subscription.eventFilters.length).to.equal(1);
                done();
            })
                .catch(done);
        });
        it('calls the error callback and passes the error provided from the platform', function (done) {
            rcsdk.getXhrResponse().add({
                path: '/restapi/v1.0/subscription',
                /**
                 * @param {XhrMock} transport
                 * @returns {Object}
                 */
                response: function (transport) {
                    transport.setStatus(400);
                    return {
                        'message': 'Subscription failed'
                    };
                }
            });
            var subscription = rcsdk.getSubscription();
            subscription
                .subscribe({
                events: ['foo']
            })
                .then(function () {
                done(new Error('This should never be reached'));
            })
                .catch(function (e) {
                expect(e.message).to.equal('Subscription failed');
                expect(e).to.be.an.instanceOf(Error);
                done();
            });
        });
    });
    describe('decrypt method', function () {
        it('provides access to PUBNUB.crypto_obj which has proper interface', function () {
            var subscription = rcsdk.getSubscription();
            expect(subscription.getPubnub().crypto_obj).to.be.an('object');
            expect(subscription.getPubnub().crypto_obj.encrypt).to.be.a('function');
            expect(subscription.getPubnub().crypto_obj.decrypt).to.be.a('function');
        });
        it('decrypts AES-encrypted messages when the subscription has an encryption key', function () {
            var aesMessage = 'gkw8EU4G1SDVa2/hrlv6+0ViIxB7N1i1z5MU/Hu2xkIKzH6yQzhr3vIc27IAN558kTOkacqE5DkLpRdnN1orwtI' +
                'BsUHmPMkMWTOLDzVr6eRk+2Gcj2Wft7ZKrCD+FCXlKYIoa98tUD2xvoYnRwxiE2QaNywl8UtjaqpTk1+WDImBrt' +
                '6uabB1WICY/qE0It3DqQ6vdUWISoTfjb+vT5h9kfZxWYUP4ykN2UtUW1biqCjj1Rb6GWGnTx6jPqF77ud0XgV1r' +
                'k/Q6heSFZWV/GP23/iytDPK1HGJoJqXPx7ErQU=', subscription = rcsdk.getSubscription();
            subscription.subscription = {
                deliveryMode: {
                    encryptionKey: 'e0bMTqmumPfFUbwzppkSbA==',
                    subscriberKey: 'foo',
                    address: 'foo'
                }
            };
            expect(subscription.decrypt(aesMessage)).to.deep.equal({
                "timestamp": "2014-03-12T20:47:54.712+0000",
                "body": {
                    "extensionId": 402853446008,
                    "telephonyStatus": "OnHold"
                },
                "event": "/restapi/v1.0/account/~/extension/402853446008/presence",
                "uuid": "db01e7de-5f3c-4ee5-ab72-f8bd3b77e308"
            });
        });
    });
    describe('destroy', function () {
        it('unsubscribes', function (done) {
            var subscription = rcsdk.getSubscription(), destroySpy = spy(function () { });
            mock.subscribeGeneric();
            subscription
                .subscribe({
                events: ['foo']
            })
                .then(function () {
                expect(subscription.subscription).not.to.equal(null);
                subscription.pubnub.unsubscribe = destroySpy;
                subscription.destroy();
                expect(destroySpy).to.be.calledOnce;
                done();
            }).catch(done);
        });
    });
});


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.core.Platform', function () {
    var platform = rcsdk.getPlatform(), releaseTimeout = platform.releaseTimeout, pollInterval = platform.pollInterval;
    afterEach(function () {
        platform.releaseTimeout = releaseTimeout;
        platform.pollInterval = pollInterval;
    });
    mock.registerHooks(this);
    describe('setCredentials', function () {
        it('should have predefined apiKey', function () {
            expect(platform.apiKey).to.equal('d2hhdGV2ZXI6d2hhdGV2ZXI='); // whatever:whatever
        });
    });
    describe('setServer', function () {
        it('should have predefined server', function () {
            expect(platform.server).to.equal('http://whatever');
        });
    });
    describe('isTokenValid', function () {
        it('is not authenticated when token has expired', function () {
            platform.cancelAccessToken();
            expect(platform.isTokenValid()).to.equal(false);
        });
        it('is not authenticated after logout', function (done) {
            platform.logout().then(function () {
                expect(platform.isTokenValid()).to.equal(false);
                done();
            }, done);
        });
        it('is not authenticated if paused', function () {
            platform.pause();
            expect(platform.isTokenValid()).to.equal(false);
            platform.resume();
        });
    });
    describe('isAuthorized', function () {
        it('initiates refresh if not authorized', function (done) {
            mock.tokenRefresh();
            expect(platform.getToken()).to.not.equal('ACCESS_TOKEN_FROM_REFRESH');
            platform
                .cancelAccessToken()
                .isAuthorized()
                .then(function () {
                expect(platform.getToken()).to.equal('ACCESS_TOKEN_FROM_REFRESH');
                done();
            })
                .catch(done);
        });
        it('waits for refresh to resolve from other tab', function (done) {
            var token = 'ACCESS_TOKEN_FROM_OTHER_TAB';
            expect(platform.getToken()).to.not.equal(token);
            platform
                .pause()
                .cancelAccessToken()
                .isAuthorized()
                .then(function () {
                expect(platform.getToken()).to.equal(token);
                done();
            })
                .catch(done);
            setTimeout(function () {
                platform.setCache({
                    access_token: token,
                    expires_in: 60 * 60 // 1 hour
                });
                platform.resume();
            }, 10);
        });
        it('produces error if refresh did not happen', function (done) {
            platform.releaseTimeout = 20;
            platform.pollInterval = 10;
            platform
                .pause()
                .cancelAccessToken()
                .isAuthorized()
                .then(function () {
                done(new Error('This should not be reached'));
            })
                .catch(function (e) {
                expect(e.message).to.equal('Automatic authentification timeout');
                done();
            });
        });
    });
    describe('apiCall', function () {
        it('refreshes token when token was expired', function (done) {
            var path = '/restapi/xxx', refreshSpy = spy(function () { });
            mock.tokenRefresh();
            mock.apiCall(path, {});
            expect(platform.getToken()).to.not.equal('ACCESS_TOKEN_FROM_REFRESH');
            platform
                .cancelAccessToken()
                .on(platform.events.refreshSuccess, refreshSpy)
                .apiCall({
                url: path
            }).then(function (ajax) {
                expect(refreshSpy).to.be.calledOnce;
                expect(platform.getToken()).to.equal('ACCESS_TOKEN_FROM_REFRESH');
                done();
            }).catch(done);
        });
        it('tries to refresh the token if Platform returns 401 Unauthorized and re-executes the request', function (done) {
            var path = '/restapi/xxx', refreshSpy = spy(function () { }), count = 0, response = { foo: 'bar' }, responseSpy = spy(function (ajax) {
                count++;
                ajax.setStatus(count == 1 ? 401 : 200);
                return count == 1 ? {} : response;
            });
            mock.tokenRefresh();
            rcsdk.getXhrResponse().add({
                path: path,
                response: responseSpy
            });
            platform
                .on(platform.events.refreshSuccess, refreshSpy)
                .apiCall({
                url: path
            }).then(function (ajax) {
                expect(refreshSpy).to.be.calledOnce;
                expect(responseSpy).to.be.calledTwice;
                expect(ajax.data).to.deep.equal(response);
                expect(platform.getToken()).to.equal('ACCESS_TOKEN_FROM_REFRESH');
                done();
            }).catch(done);
        });
        it('fails if ajax has status other than 2xx', function (done) {
            var path = '/restapi/xxx';
            rcsdk.getXhrResponse().add({
                path: path,
                response: function (ajax) {
                    ajax.setStatus(400);
                    return { description: 'Fail' };
                }
            });
            platform
                .apiCall({
                url: path
            }).then(function (ajax) {
                done(new Error('This should not be reached'));
            }).catch(function (e) {
                expect(e.message).to.equal('Fail');
                done();
            });
        });
    });
    describe('refresh', function () {
        it('handles error in queued AJAX after unsuccessful refresh when token is killed', function (done) {
            var path = '/restapi/xxx', successSpy = spy(function () { }), errorSpy = spy(function () { });
            mock.tokenRefresh(true);
            mock.apiCall(path, {});
            platform
                .cancelAccessToken()
                .on(platform.events.refreshSuccess, successSpy)
                .on(platform.events.refreshError, errorSpy)
                .apiCall({
                url: path
            })
                .then(function () {
                done(new Error('This should never be called'));
            })
                .catch(function (e) {
                expect(e.message).to.equal('Wrong token');
                expect(errorSpy).to.be.calledOnce;
                expect(successSpy).not.to.calledOnce;
                done();
            });
        });
        it('sits and waits for the queue to be released, no matter how many pending refreshes there are', function (done) {
            platform.pause();
            rcsdk.getContext().getPromise()
                .all([
                platform.refresh(),
                platform.refresh(),
                platform.refresh()
            ])
                .then(function () {
                done();
            })
                .catch(function (e) {
                done(e);
            });
            setTimeout(function () {
                platform.resume();
            }, 5);
        });
        it('handles subsequent refreshes', function (done) {
            mock.tokenRefresh();
            platform.refresh()
                .then(function () {
                return platform.refresh();
            })
                .then(function () {
                return rcsdk.getContext().getPromise()
                    .all([
                    platform.refresh(),
                    platform.refresh()
                ]);
            })
                .then(function () {
                done();
            })
                .catch(function (e) {
                done(e);
            });
        });
        it('returns error if response is malformed', function (done) {
            rcsdk.getXhrResponse().add({
                path: '/restapi/oauth/token',
                /**
                 * @param {XhrMock} ajax
                 * @returns {Object}
                 */
                response: function (ajax) {
                    ajax.setStatus(240); // This weird status were caught on client's machine
                    return {
                        'message': 'Wrong token',
                        'error_description': 'Wrong token',
                        'description': 'Wrong token'
                    };
                }
            });
            platform.cancelAccessToken().refresh().then(function () {
                done(new Error('This should not be reached'));
            }).catch(function (e) {
                expect(e.message).to.equal('Malformed OAuth response');
                expect(e.ajax.data.message).to.equal('Wrong token');
                done();
            });
        });
        it('issues only one refresh request', function (done) {
            var Promise = rcsdk.getContext().getPromise();
            var spy1 = spy(function (ajax) {
                return new Promise(function (resolve, reject) {
                    setTimeout(function () {
                        resolve({
                            'access_token': 'ACCESS_TOKEN_FROM_REFRESH',
                            'token_type': 'bearer',
                            'expires_in': 3600,
                            'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',
                            'refresh_token_expires_in': 60480,
                            'scope': 'SMS RCM Foo Boo',
                            'expireTime': new Date().getTime() + 3600000
                        });
                    }, 50);
                });
            });
            var increment = 0;
            var spy2 = spy(function (ajax) {
                return {
                    increment: ++increment,
                    constant: 1
                };
            });
            rcsdk.getXhrResponse().add({
                path: '/restapi/oauth/token',
                /**
                 * @param {XhrMock} ajax
                 * @returns {Object}
                 */
                response: spy1
            });
            rcsdk.getXhrResponse().add({
                path: '/restapi/v1.0/foo',
                /**
                 * @param {XhrMock} ajax
                 * @returns {Object}
                 */
                response: spy2
            });
            platform.cancelAccessToken();
            Promise
                .all([
                platform.apiCall({ url: '/foo' }),
                platform.apiCall({ url: '/foo' }),
                platform.apiCall({ url: '/foo' })
            ])
                .then(function (res) {
                expect(res[0].data.increment).to.equal(1);
                expect(res[1].data.increment).to.equal(2);
                expect(res[2].data.increment).to.equal(3);
                expect(res[0].data.constant).to.equal(res[1].data.constant);
                expect(spy1).to.be.calledOnce;
                expect(spy2).to.be.calledThrice;
                done();
            })
                .catch(done);
        });
        it('immediately (synchronously) pauses', function (done) {
            mock.tokenRefresh();
            var refresh = platform.refresh();
            expect(platform.isPaused()).to.equal(true);
            refresh
                .then(function () {
                done();
            })
                .catch(function (e) {
                done(e);
            });
        });
        it('throws error if queue was unpaused before refresh call', function (done) {
            mock.tokenRefresh();
            var refresh = platform.refresh();
            platform.resume();
            refresh
                .then(function () {
                done(new Error('This should not be reached'));
            })
                .catch(function (e) {
                expect(e.message).to.equal('Queue was resumed before refresh call');
                done();
            });
        });
    });
    describe('refreshPolling', function () {
        beforeEach(function () {
            platform.releaseTimeout = 20;
            platform.pollInterval = 10;
        });
        it('polls the status of semaphor and resumes operation', function (done) {
            platform
                .pause()
                .refreshPolling(null)
                .then(function () {
                done();
            })
                .catch(done);
            setTimeout(function () {
                platform.resume();
            }, 10);
        });
        it('resolves with error if token is not valid after releaseTimeout', function (done) {
            platform
                .pause() // resume() will not be called in this test
                .cancelAccessToken()
                .refreshPolling(null)
                .then(function () {
                done(new Error('This should not be reached'));
            })
                .catch(function (e) {
                expect(e.message).to.equal('Automatic authentification timeout');
                done();
            });
        });
    });
    describe('get, post, put, delete', function () {
        it('sends request using appropriate method', function (done) {
            function test(method) {
                var path = '/foo/' + method;
                rcsdk.getXhrResponse().add({
                    path: path,
                    response: function (ajax) {
                        expect(ajax.method).to.equal(method.toUpperCase());
                        return { foo: 'bar' };
                    }
                });
                return platform[method](path).then(function (res) {
                    expect(res.data.foo).to.equal('bar');
                    return res;
                });
            }
            rcsdk.getContext().getPromise().all([
                test('get'),
                test('post'),
                test('put'),
                test('delete')
            ]).then(function () {
                done();
            }).catch(done);
        });
    });
    //TODO Add tests for this
    describe.skip('parseAuthRedirectUrl', function () { });
    describe.skip('getAuthURL', function () { });
    describe.skip('getCredentials', function () { });
});


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.core.Observable', function () {
    describe('Regular events', function () {
        it('binds and fires events', function () {
            var o = rcsdk.getObservable(), a = 0;
            o.on('event', function () {
                a++;
            });
            o.emit('event');
            expect(a).to.be.equal(1);
            o.emit('event');
            expect(a).to.be.equal(2);
        });
        it('binds and unbinds events', function () {
            var o = rcsdk.getObservable(), a = 0, c = function () {
                a++;
            };
            o.on('event', c);
            o.off('event', c);
            o.emit('event');
            expect(a).to.be.equal(0);
        });
        it('don\'t share events', function () {
            var o1 = rcsdk.getObservable(), o2 = rcsdk.getObservable(), a = 0, c = function () {
                a++;
            };
            o1.on('event', c);
            o2.on('event', c);
            o1.emit('event');
            o2.emit('event');
            expect(a).to.be.equal(2);
        });
        it('executes event and then callback when emitAndCallback() is called', function () {
            var o = rcsdk.getObservable(), r = '';
            o.on('event', function (a, b) {
                r += '1-' + a + '-' + b;
            });
            o.emitAndCallback('event', [2, 3], function () {
                r += '-4';
            });
            expect(r).to.equal('1-2-3-4');
        });
    });
    describe('Disposable events', function () {
        it('executes callback immediately if event has been fired before', function () {
            var o = rcsdk.getObservable(), a = 0;
            o.registerOneTimeEvent('event');
            o.on('event', function () {
                a++;
            });
            o.emit('event');
            expect(a).to.be.equal(1);
            o.on('event', function () { a++; });
            expect(a).to.be.equal(2);
        });
    });
});


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.core.Log', function () {
    var log = rcsdk.getLog();
    describe('Interface', function () {
        it('Enables and disables all', function () {
            var originalConsole = console;
            var c = log.console = {
                log: spy(function () { }),
                info: spy(function () { }),
                warn: spy(function () { }),
                error: spy(function () { })
            };
            log.enableAll();
            expect(log.logDebug).to.equal(true);
            expect(log.logInfo).to.equal(true);
            expect(log.logWarnings).to.equal(true);
            expect(log.logErrors).to.equal(true);
            log.debug('foo');
            log.info('foo');
            log.warn('foo');
            log.error('foo');
            log.disableAll();
            expect(log.logDebug).to.equal(false);
            expect(log.logInfo).to.equal(false);
            expect(log.logWarnings).to.equal(false);
            expect(log.logErrors).to.equal(false);
            log.debug('foo');
            log.info('foo');
            log.warn('foo');
            log.error('foo');
            expect(c.log).to.be.calledOnce;
            expect(c.info).to.be.calledOnce;
            expect(c.warn).to.be.calledOnce;
            expect(c.error).to.be.calledOnce;
            log.console = originalConsole;
        });
    });
});


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.core.List', function () {
    'use strict';
    var List = rcsdk.getList();
    describe('stringComparator', function () {
        it('compares values as strings', function () {
            // numbers with different amount of digits
            expect(List.stringComparator('12', '2')).to.equal(-1);
            expect(List.stringComparator('2', '12')).to.equal(1);
            // numbers with same amount of digits
            expect(List.stringComparator('1', '2')).to.equal(-1);
            expect(List.stringComparator('2', '1')).to.equal(1);
            // same numbers
            expect(List.stringComparator('1', '1')).to.equal(0);
            // english strings
            expect(List.stringComparator('a', 'b')).to.equal(-1);
            expect(List.stringComparator('b', 'a')).to.equal(1);
            expect(List.stringComparator('a', 'a')).to.equal(0);
            // russian strings
            expect(List.stringComparator('в', 'г')).to.equal(-1);
            expect(List.stringComparator('г', 'в')).to.equal(1);
            expect(List.stringComparator('г', 'г')).to.equal(0);
        });
        it('compares values as numbers', function () {
            // numbers with different amount of digits as strings, <number> is used to convince TS
            expect(List.numberComparator('12', '2')).to.equal(10);
            expect(List.numberComparator('2', '12')).to.equal(-10);
            // numbers with different amount of digits
            expect(List.numberComparator(12, 2)).to.equal(10);
            expect(List.numberComparator(2, 12)).to.equal(-10);
            // numbers with same amount of digits
            expect(List.numberComparator(1, 2)).to.equal(-1);
            expect(List.numberComparator(2, 1)).to.equal(1);
            // same numbers
            expect(List.numberComparator(1, 1)).to.equal(0);
        });
    });
    describe('comparator', function () {
        it('by default provides comparator function which calls stringComparator with pre-bound extract functions', function () {
            var array = [
                { id: '3' },
                { id: '2' },
                { id: '1' }
            ], sortFn = List.comparator({ sortBy: 'id' }), result = array
                .map(function (item) { return item; }) // we need a copy, original array is sorted in-place
                .sort(sortFn);
            expect(result[0]).to.equal(array[2]);
            expect(result[1]).to.equal(array[1]);
            expect(result[2]).to.equal(array[0]);
        });
        it('allows to provide custom sortBy property', function () {
            var array = [
                { name: '3' },
                { name: '2' },
                { name: '1' }
            ], sortFn = List.comparator({ sortBy: 'name' }), result = array
                .map(function (item) { return item; }) // we need a copy, original array is sorted in-place
                .sort(sortFn);
            expect(result[0]).to.equal(array[2]);
            expect(result[1]).to.equal(array[1]);
            expect(result[2]).to.equal(array[0]);
        });
        it('allows to provide custom extract and compare functions', function () {
            var array = [
                { id: '13' },
                { id: '2' },
                { id: '1' }
            ], sortFn = List.comparator({
                compareFn: List.numberComparator,
                sortBy: 'id'
            }), result = array
                .map(function (item) { return item; }) // we need a copy, original array is sorted in-place
                .sort(sortFn);
            expect(result[0]).to.equal(array[2]);
            expect(result[1]).to.equal(array[1]);
            expect(result[2]).to.equal(array[0]);
        });
        it('provides options to custom extract and compare functions', function () {
            var array = [
                { id: '3' },
                { id: '2' },
                { id: '1' }
            ], options = {
                sortBy: 'id',
                extractFn: spy(function (item, opts) {
                    expect(opts.extractFn).to.equal(options.extractFn);
                    expect(opts.compareFn).to.equal(options.compareFn);
                    return List.propertyExtractor('id')(item, opts);
                }),
                compareFn: spy(function (a, b, opts) {
                    expect(opts.extractFn).to.equal(options.extractFn);
                    expect(opts.compareFn).to.equal(options.compareFn);
                    return List.numberComparator(a, b, opts);
                })
            }, sortFn = List.comparator(options), result = array
                .map(function (item) { return item; }) // we need a copy, original array is sorted in-place
                .sort(sortFn);
            expect(result[0]).to.equal(array[2]);
            expect(result[1]).to.equal(array[1]);
            expect(result[2]).to.equal(array[0]);
            expect(options.extractFn.callCount).to.be.equal(array.length * 2);
            expect(options.compareFn.callCount).to.be.equal(array.length);
        });
    });
    describe('propertyExtractor', function () {
        it('returns a value of property', function () {
            expect(List.propertyExtractor('id')({ id: 'foo' })).to.equal('foo');
            expect(List.propertyExtractor('id')(undefined)).to.equal(null);
            expect(List.propertyExtractor(null)('foo')).to.equal('foo');
            expect(List.propertyExtractor(null)({ id: 'foo' })).to.deep.equal({ id: 'foo' });
        });
    });
});


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var r = __webpack_require__(18);
var expect = exports.mocha.chai.expect;
var rcsdk = exports.mocha.mock.rcsdk;
describe('RCSDK.core.http.Response', function () {
    "use strict";
    describe('constructor tests', function () {
        var goodMultipartMixedResponse = '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\r\n' +
            '\r\n' +
            '{\n' +
            '  "response" : [ {\n' +
            '    "status" : 200\n' +
            '  }, {\n' +
            '    "status" : 200\n' +
            '  } ]\n' +
            '}\n' +
            '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\n' +
            '\n' +
            '{\n' +
            '  "foo" : "bar"\n' +
            '}\n' +
            '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\n' +
            '\n' +
            '{\n' +
            '  "baz" : "qux"\n' +
            '}\n' +
            '--Boundary_1245_945802293_1394135045248--\n', multipartMixedResponseWithErrorPart = '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\n' +
            '\n' +
            '{\n' +
            '  "response" : [ {\n' +
            '    "status" : 200\n' +
            '  }, {\n' +
            '    "status" : 404\n' +
            '  }, {\n' +
            '    "status" : 200\n' +
            '  } ]\n' +
            '}\n' +
            '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\n' +
            '\n' +
            '{\n' +
            '  "foo" : "bar"\n' +
            '}\n' +
            '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\n' +
            '\n' +
            '{\n' +
            '  "message" : "object not found"\n' +
            '}\n' +
            '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\n' +
            '\n' +
            '{\n' +
            '  "baz" : "qux"\n' +
            '}\n' +
            '--Boundary_1245_945802293_1394135045248--\n', badMultipartMixedResponse = '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\n' +
            '\n' +
            'THIS IS JUNK AND CANNOT BE PARSED AS JSON\n' +
            '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\n' +
            '\n' +
            '{\n' +
            '  "foo" : "bar"\n' +
            '}\n' +
            '--Boundary_1245_945802293_1394135045248\n' +
            'Content-Type: application/json\n' +
            '\n' +
            '{\n' +
            '  "baz" : "qux"\n' +
            '}\n' +
            '--Boundary_1245_945802293_1394135045248--\n', multipartResponseHeaders = {
            'content-type': 'multipart/mixed; boundary=Boundary_1245_945802293_1394135045248'
        }, jsonResponseHeaders = {
            'content-type': 'application/json; encoding=utf8'
        };
        it('parses headers into object', function () {
            expect(r.$get(rcsdk.getContext(), 200, 'OK', '{}', jsonResponseHeaders).isJson()).to.equal(true);
            expect(r.$get(rcsdk.getContext(), 207, 'Multi-Status', '{}', multipartResponseHeaders).isMultipart()).to.equal(true);
        });
        it('calls the success callback after parsing a good multi-part/mixed response', function () {
            var response = r.$get(rcsdk.getContext(), 207, 'Multi-Status', goodMultipartMixedResponse, multipartResponseHeaders);
            expect(response.error).to.equal(null);
        });
        it('calls the success callback for all individual parts that are parsed (including errors)', function () {
            var res = r.$get(rcsdk.getContext(), 207, 'Multi-Status', multipartMixedResponseWithErrorPart, multipartResponseHeaders);
            expect(res.error).to.equal(null);
            expect(res.data.length).to.equal(3);
            //expect(res.data[0]).to.be.instanceOf(r.Response); //FIXME
            expect(res.data[0].error).to.be.equal(null);
            expect(res.data[0].data.foo).to.be.equal('bar');
            expect(res.data[0].status).to.be.equal(200);
            //expect(res.data[1]).to.be.instanceOf(r.Response); //FIXME
            expect(res.data[1].error).to.be.instanceOf(Error);
            //expect(res.data[2]).to.be.instanceOf(r.Response); //FIXME
            expect(res.data[2].error).to.be.equal(null);
            expect(res.data[2].data.baz).to.be.equal('qux');
            expect(res.data[2].status).to.be.equal(200);
        });
        it('calls the error callback if it fails to parse the parts info block', function () {
            var response = r.$get(rcsdk.getContext(), 207, 'Multi-Status', badMultipartMixedResponse, multipartResponseHeaders);
            expect(response.error).to.be.an.instanceof(Error);
        });
        it('calls the error callback if it is unable to parse the JSON data, passing the error object', function () {
            var response = r.$get(rcsdk.getContext(), 200, 'OK', 'THIS IS JUNK', jsonResponseHeaders);
            expect(response.error).to.be.an.instanceof(Error);
            expect(response.body).to.equal('THIS IS JUNK');
        });
        it('uses the error_description property of the JSON data when there is an error but no message property', function () {
            var response = r.$get(rcsdk.getContext(), 404, 'Error', '{"error_description": "ERROR"}', jsonResponseHeaders);
            expect(response.error).to.be.an.instanceof(Error);
            expect(response.error.message).to.equal('ERROR');
        });
        it('uses the description property of the JSON data when there is an error but no message or error_description properties', function () {
            var response = r.$get(rcsdk.getContext(), 404, 'Error', '{"description": "ERROR"}', jsonResponseHeaders);
            expect(response.error).to.be.an.instanceof(Error);
            expect(response.error.message).to.equal('ERROR');
        });
        it('parses empty response', function () {
            var response = r.$get(rcsdk.getContext(), 204, 'No Content', '', jsonResponseHeaders);
            expect(response.error).to.equal(null);
            expect(response.data).to.equal('');
        });
        it('parses empty response', function () {
            var response = r.$get(rcsdk.getContext(), 200, 'OK', '{"foo":"bar"}', null);
            expect(response.error).to.equal(null);
            expect(response.data).to.deep.equal({ foo: 'bar' });
            expect(response.getHeader('content-type')).to.equal('application/json');
        });
    });
});


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var r = __webpack_require__(16);
var expect = exports.mocha.chai.expect;
var rcsdk = exports.mocha.mock.rcsdk;
describe('RCSDK.core.http.Request', function () {
    describe('send', function () {
        it('calls error callback if the URL is not specified or is falsy', function (done) {
            r.$get(rcsdk.getContext()).send().catch(function (e) {
                expect(e).to.be.instanceOf(Error);
                done();
            });
        });
    });
    describe('checkOptions', function () {
        it('defaults the method option to GET', function () {
            var ajax = r.$get(rcsdk.getContext()).setOptions({ url: '/foo/bar' });
            ajax.checkOptions();
            expect(ajax.method).to.equal('GET');
        });
        it('it uppercases the method option, if specified', function () {
            var ajax = r.$get(rcsdk.getContext()).setOptions({ url: '/foo/bar', method: 'get' });
            ajax.checkOptions();
            expect(ajax.method).to.equal('GET');
        });
        it('it uses the value of the async option, if specified', function () {
            var ajax = r.$get(rcsdk.getContext()).setOptions({ url: '/foo/bar', async: false });
            ajax.checkOptions();
            expect(ajax.async).to.equal(false);
        });
        it('it defaults the async option to true, if not specified', function () {
            var ajax = r.$get(rcsdk.getContext()).setOptions({ url: '/foo/bar' });
            ajax.checkOptions();
            expect(ajax.async).to.equal(true);
        });
        it('it defaults the headers option to an empty object, and then merges it with the default headers', function () {
            var ajax = r.$get(rcsdk.getContext()).setOptions({ url: '/foo/bar' });
            ajax.checkOptions();
            expect(ajax.getHeader('Accept')).to.equal('application/json');
            expect(ajax.getHeader('Content-Type')).to.equal('application/json');
        });
        it('it merges the specified headers with the default headers, giving the specified headers priority', function () {
            var ajax = r.$get(rcsdk.getContext()).setOptions({
                url: '/foo/bar',
                headers: {
                    'Accept': 'application/foo-bar',
                    'Transfer-Encoding': 'chunked'
                }
            });
            ajax.checkOptions();
            expect(ajax.getHeader('Accept')).to.equal('application/foo-bar');
            expect(ajax.getHeader('Content-Type')).to.equal('application/json');
            expect(ajax.getHeader('Transfer-Encoding')).to.equal('chunked');
        });
    });
    describe('destroy', function () {
        it('aborts the native XHR object', function (done) {
            var ajax = r.$get(rcsdk.getContext());
            // Mock the XHR object
            ajax.xhr = {
                abort: function () {
                    done();
                }
            };
            ajax.destroy();
        });
    });
});


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var r = __webpack_require__(89);
var expect = exports.mocha.chai.expect;
var rcsdk = exports.mocha.mock.rcsdk;
describe('RCSDK.core.http.MultipartRequest', function () {
    describe.skip('createNodeMessage', function () {
        it('assembles message', function () {
            var req = r.$get(rcsdk.getContext()), expected = '--Boundary_1428971641708\n' +
                'Content-Type: application/json\n' +
                '\n' +
                '{}\n' +
                '--Boundary_1428971641708\n' +
                'Content-Type: text/plain\n' +
                '\n' +
                'Foo\n' +
                '--Boundary_1428971641708--';
            req.setBoundary('Boundary_1428971641708')
                .addAttachment({ content: 'Foo' })
                .createNodeMessage();
            expect(req.body).to.be.instanceOf(Buffer);
            expect(req.body.toString('utf-8')).to.equal(expected);
        });
        it('assembles message', function () {
            var req = r.$get(rcsdk.getContext()), expected = '--Boundary_1428971641708\n' +
                'Content-Type: application/json\n' +
                '\n' +
                '{}\n' +
                '--Boundary_1428971641708\n' +
                'Content-Type: application/json\n' +
                'Content-Disposition: attachment; filename=file.txt\n' +
                '\n' +
                '{"foo":"bar"}\n' +
                '--Boundary_1428971641708--';
            req.setBoundary('Boundary_1428971641708')
                .addAttachment({ contentType: 'application/json', content: new Buffer('{"foo":"bar"}', 'utf-8') })
                .createNodeMessage();
            expect(req.body).to.be.instanceOf(Buffer);
            expect(req.body.toString('utf-8')).to.equal(expected);
        });
        it('assembles message', function () {
            var req = r.$get(rcsdk.getContext()), expected = '--Boundary_1428971641708\n' +
                'Content-Type: application/json\n' +
                '\n' +
                '{"to":[{"phoneNumber":"12223334455"}],"faxResolution":"Low"}\n' +
                '--Boundary_1428971641708\n' +
                'Content-Type: application/json\n' +
                'Content-Disposition: attachment; filename=file.txt\n' +
                '\n' +
                '{"foo":"bar"}\n' +
                '--Boundary_1428971641708--';
            req.body = {
                "to": [{ "phoneNumber": "12223334455" }],
                "faxResolution": "Low"
            };
            req.setBoundary('Boundary_1428971641708')
                .addAttachment({ contentType: 'application/json', content: new Buffer('{"foo":"bar"}', 'utf-8') })
                .createNodeMessage();
            expect(req.body).to.be.instanceOf(Buffer);
            expect(req.body.toString('utf-8')).to.equal(expected);
        });
    });
});


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../../typings/externals.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var req = __webpack_require__(16);
var MultipartRequest = (function (_super) {
    __extends(MultipartRequest, _super);
    function MultipartRequest() {
        _super.apply(this, arguments);
        this.attachments = [];
    }
    MultipartRequest.prototype.addAttachment = function (attachment) {
        this.attachments.push(attachment);
        return this;
    };
    MultipartRequest.prototype.setBoundary = function (boundary) {
        this.boundary = boundary;
        return this;
    };
    MultipartRequest.prototype.createNodeMessage = function () {
        var _this = this;
        this.boundary = this.boundary || 'Boundary_' + Date.now();
        var messageParts = [];
        messageParts.push('--' + this.boundary + '\n');
        messageParts.push('Content-Type: application/json\n');
        messageParts.push('\n');
        messageParts.push(JSON.stringify(this.body) + '\n');
        this.attachments.forEach(function (attachment) {
            if (!attachment.contentType)
                attachment.contentType = 'text/plain';
            messageParts.push('--' + _this.boundary + '\n');
            messageParts.push('Content-Type: ' + attachment.contentType + '\n');
            if (attachment.contentType != 'text/plain' || !!attachment.name) {
                messageParts.push('Content-Disposition: attachment; filename=' + (attachment.name || 'file.txt') + '\n');
            }
            messageParts.push('\n');
            messageParts.push(attachment.content || '');
            messageParts.push('\n');
        });
        messageParts.push('--' + this.boundary + '--');
        this.setContentType('multipart/mixed; boundary=' + this.boundary);
        this.body = Buffer.concat(messageParts.map(function (msg) {
            return (msg instanceof Buffer) ? msg : new Buffer(msg, 'utf-8');
        }));
    };
    MultipartRequest.prototype.createBrowserMessage = function () {
        var formData = new FormData();
        formData.append('platform-json-payload', new File([JSON.stringify(this.body)], 'request.json', { type: 'application/json' }));
        this.attachments.forEach(function (attachment) {
            formData.append(attachment.name, attachment);
        });
        this.setContentType('');
        this.body = formData;
    };
    MultipartRequest.prototype.send = function () {
        if (typeof Buffer == 'function') {
            this.createNodeMessage();
        }
        else {
            this.createBrowserMessage();
        }
        return _super.prototype.send.call(this);
    };
    return MultipartRequest;
})(req.Request);
exports.MultipartRequest = MultipartRequest;
function $get(context) {
    return new MultipartRequest(context);
}
exports.$get = $get;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var r = __webpack_require__(18);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.core.Helper', function () {
    'use strict';
    var Helper = rcsdk.getHelper(), defaultUrl = 'default', defaultSyncUrl = 'default-sync';
    function attachSpy(suite) {
        suite.beforeEach(function () {
            this._createUrl = Helper.createUrl.bind(Helper);
            Helper.createUrl = spy(function (options) {
                options = options || {};
                return (options.sync ? defaultSyncUrl : defaultUrl);
            });
        });
        suite.afterEach(function () {
            Helper.createUrl = this._createUrl;
        });
    }
    describe('getId', function () {
        it('return value of object.id', function () {
            expect(Helper.getId({ id: 'foo' })).to.equal('foo');
            expect(Helper.getId({})).to.be.an('undefined');
        });
    });
    describe('isNew', function () {
        it('returns true if object does not have id or url', function () {
            expect(Helper.isNew({ id: 'foo' })).to.equal(true);
            expect(Helper.isNew({ uri: 'foo' })).to.equal(true);
            expect(Helper.isNew({})).to.equal(true);
            expect(Helper.isNew({ id: 'foo', uri: 'bar' })).to.equal(false);
        });
    });
    describe('loadRequest', function () {
        attachSpy(this);
        it('provides given url, if not - object.url, if not - default url', function () {
            expect(Helper.loadRequest({ uri: 'object-uri' }, { url: 'given-url' }).url).to.equal('given-url');
            expect(Helper.loadRequest(null, { url: 'given-url' }).url).to.equal('given-url');
            expect(Helper.loadRequest({ uri: 'object-uri' }).url).to.equal('object-uri');
            expect(Helper.loadRequest().url).to.equal(defaultUrl);
            expect(Helper.createUrl).to.be.calledOnce;
        });
    });
    describe('saveRequest', function () {
        attachSpy(this);
        it('provides given url, if not - object.url, if not - default url', function () {
            expect(Helper.saveRequest({ uri: 'object-uri' }, { url: 'given-url' }).url).to.equal('given-url');
            expect(Helper.saveRequest({ uri: 'object-uri' }).url).to.equal('object-uri');
            expect(Helper.saveRequest({}, {}).url).to.equal(defaultUrl);
            expect(Helper.createUrl).to.be.calledOnce;
        });
        it('throws exceptions if no object is provided', function () {
            expect(function () { Helper.saveRequest(); }).to.throw(Error);
        });
    });
    describe('deleteRequest', function () {
        attachSpy(this);
        it('provides given url, if not - object.url, if not - exception', function () {
            expect(Helper.deleteRequest({ uri: 'object-uri' }, { url: 'given-url' }).url).to.equal('given-url');
            expect(Helper.deleteRequest({ uri: 'object-uri' }).url).to.equal('object-uri');
            expect(function () { Helper.deleteRequest({}); }).to.throw(Error);
        });
        it('throws exceptions if no object is provided', function () {
            expect(function () { Helper.deleteRequest(); }).to.throw(Error);
        });
    });
    describe('syncRequest', function () {
        attachSpy(this);
        it('provides default sync url if nothing was given', function () {
            expect(Helper.syncRequest({ url: 'given-url' }).url).to.equal('given-url');
            expect(Helper.syncRequest().url).to.equal(defaultSyncUrl);
            expect(Helper.createUrl).to.be.calledOnce;
        });
        it('sets syncType to FSync if no syncToken was given', function () {
            expect(Helper.syncRequest().query.syncType).to.equal('FSync');
        });
        it('sets syncType to ISync if syncToken was given and deletes all other options.get', function () {
            var options = {
                get: {
                    syncToken: 'foo',
                    foo: 'foo'
                }
            }, request = Helper.syncRequest(options);
            expect(request.query.foo).to.be.an('undefined');
            expect(request.query.syncType).to.equal('ISync');
            expect(request.query.syncToken).to.equal(options.get.syncToken);
        });
    });
    describe('index', function () {
        it('creates an indexed object of given array items', function () {
            var array = [
                { id: 'foo', name: 'foo' },
                { id: 'bar', name: 'bar' }
            ], index = Helper.index(array);
            expect(index.foo).to.equal(array[0]);
            expect(index.bar).to.equal(array[1]);
        });
        it('creates an indexed object using given getId callback of given array items', function () {
            // array items should not have name property to ensure test is real
            var array = [
                { name: 'foo' },
                { name: 'bar' }
            ], index = Helper.index(array, function (item) { return item.name; });
            expect(index.foo).to.equal(array[0]);
            expect(index.bar).to.equal(array[1]);
        });
        it('if two or more items have same id the first wins by default', function () {
            var array = [
                { id: 'foo', name: 'foo' },
                { id: 'foo', name: 'bar' }
            ], index = Helper.index(array);
            expect(index.foo).to.equal(array[0]);
            expect(Object.keys(index)).to.deep.equal(['foo']);
            expect(Object.keys(index).length).to.equal(1);
        });
        it('if two or more items have same id resulting index will contain an array of them if flag is provided', function () {
            var array = [
                { id: 'foo', name: 'foo' },
                { id: 'foo', name: 'bar' }
            ], index = Helper.index(array, null, true);
            expect(index.foo).to.deep.equal(array);
            expect(Object.keys(index)).to.deep.equal(['foo']);
            expect(Object.keys(index).length).to.equal(1);
        });
        it('if items do not have id resulting index will not contain them', function () {
            var array = [
                { id: 'foo', name: 'foo' },
                { name: 'bar' }
            ], index = Helper.index(array);
            expect(index.foo).to.equal(array[0]);
            expect(Object.keys(index)).to.deep.equal(['foo']);
            expect(Object.keys(index).length).to.equal(1);
        });
    });
    describe('merge', function () {
        it('replaces target items with supplement ones if they same ids, original target items stay untouched', function () {
            var target = [
                { id: 'foo', name: 'foo' },
                { id: 'bar', name: 'bar' }
            ], supplement = [
                { id: 'foo', name: 'foo-x' }
            ], merged = Helper.merge(target, supplement);
            // merged first item belongs to supplement
            expect(merged[0]).to.equal(supplement[0]);
            // target item is not in merged array
            expect(merged.indexOf(target[0])).to.equal(-1);
            expect(merged[0].id).to.equal('foo');
            expect(merged[0].name).to.equal('foo-x');
            // target item stays untouched
            expect(target[0].name).to.equal('foo');
            expect(merged.length).to.equal(2);
        });
        it('applies properties of supplement to target items if they have same ids (target items are mutated)', function () {
            var target = [
                { id: 'foo', name: 'foo' },
                { id: 'bar', name: 'bar' }
            ], supplement = [
                { id: 'foo', name: 'foo-x' }
            ], merged = Helper.merge(target, supplement, null, true);
            // merged first item belongs to target
            expect(merged[0]).to.not.equal(supplement[0]);
            expect(merged[0]).to.equal(target[0]);
            // merged item has new properties and proper id
            expect(merged[0].id).to.equal('foo');
            expect(merged[0].name).to.equal('foo-x');
            // target item was mutated
            expect(target[0].name).to.equal('foo-x');
            expect(merged.length).to.equal(2);
        });
        it('allows to provide custom getId function)', function () {
            var target = [
                { id: 'foo', name: 'foo' },
                { id: 'bar', name: 'bar' }
            ], supplement = [
                { id: 'foo-x', name: 'foo' }
            ], merged = Helper.merge(target, supplement, function (item) { return item.name; });
            // merged first item belongs to supplement
            expect(merged[0]).to.equal(supplement[0]);
            // target item is not in merged array
            expect(merged.indexOf(target[0])).to.equal(-1);
            // merged item has new properties and proper id
            expect(merged[0].name).to.equal('foo');
            expect(merged[0].id).to.equal('foo-x');
            // target item stays untouched
            expect(target[0].id).to.equal('foo');
            expect(merged.length).to.equal(2);
        });
        it('appends supplement', function () {
            var target = [
                { id: 'foo', name: 'foo' },
                { id: 'bar', name: 'bar' }
            ], supplement = [
                { id: 'foo-x', name: 'foo' }
            ], merged = Helper.merge(target, supplement);
            expect(merged.length).to.equal(3);
            expect(merged[2].name).to.equal('foo');
            expect(merged[2].id).to.equal('foo-x');
        });
    });
    describe('parseMultipartResponse', function () {
        it('evaluates multipart response', function () {
            var ajax = {
                isMultipart: function () {
                    return true;
                },
                data: [
                    { data: 'foo' },
                    { data: 'bar' },
                    { error: new Error('this is skipped') }
                ]
            };
            var items = Helper.parseMultipartResponse(ajax);
            expect(ajax.isMultipart()).to.equal(true);
            expect(items).to.deep.equal(['foo', 'bar']);
            expect(items.length).to.equal(2);
        });
        it('evaluates one-item response', function () {
            var ajax = r.$get(rcsdk.getContext(), 200, 'OK', { foo: 'foo' }), items = Helper.parseMultipartResponse(ajax);
            expect(items).to.deep.equal([{ foo: 'foo' }]);
            expect(items.length).to.equal(1);
        });
    });
});


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

/// <reference path="../../typings/externals.d.ts" />
exports.mocha = __webpack_require__(58);
var expect = exports.mocha.chai.expect;
var spy = exports.mocha.sinon.spy;
var mock = exports.mocha.mock;
var rcsdk = exports.mocha.rcsdk;
describe('RCSDK.core.AjaxObserver', function () {
    var o = rcsdk.getAjaxObserver(), platform = rcsdk.getPlatform(), path = '/restapi/xxx';
    describe('events fire when Ajax happen', function () {
        mock.registerHooks(this);
        afterEach(function () {
            o.offAll();
        });
        beforeEach(function () {
            o.offAll();
        });
        it('beforeRequest', function (done) {
            mock.apiCall(path, {});
            var xspy = spy(function (ajax) { });
            o.on(o.events.beforeRequest, xspy);
            platform
                .apiCall({ url: path })
                .then(function () {
                expect(xspy).to.be.calledOnce;
                done();
            })
                .catch(function (e) { done(e); });
        });
        it('requestSuccess', function (done) {
            mock.apiCall(path, {});
            var xspy = spy(function (ajax) { });
            o.on(o.events.requestSuccess, xspy);
            platform
                .apiCall({ url: path })
                .then(function () {
                expect(xspy).to.be.calledOnce;
                done();
            })
                .catch(function (e) { done(e); });
        });
        it('requestError', function (done) {
            var xspy = spy(function (ajax) { });
            o.on(o.events.requestError, xspy);
            platform
                .apiCall({ url: path })
                .then(function () {
                done(new Error('This should never be reached'));
            })
                .catch(function (e) {
                expect(xspy).to.be.calledOnce;
                done();
            });
        });
    });
});


/***/ }
/******/ ])
});
;
//# sourceMappingURL=specs.js.map